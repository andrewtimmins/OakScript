#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "h.string"
#include "h.memory" // remap malloc/free to module-safe versions

/* ASCII character classification and conversion functions */
int ascii_isspace(char c) { 
    return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v' || c == '\f'; 
}

int ascii_isdigit(char c) { 
    return c >= '0' && c <= '9'; 
}

int ascii_isalpha(char c) { 
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); 
}

int ascii_isalnum(char c) { 
    return ascii_isalpha(c) || ascii_isdigit(c); 
}

char ascii_toupper(char c) { 
    return (c >= 'a' && c <= 'z') ? (char)(c - 'a' + 'A') : c; 
}

char ascii_tolower(char c) { 
    return (c >= 'A' && c <= 'Z') ? (char)(c - 'A' + 'a') : c; 
}

/* String manipulation functions */
void to_upper_inplace(char *s) { 
    for (size_t i = 0; s[i] != '\0'; i++) {
        s[i] = ascii_toupper(s[i]); 
    }
}

void to_lower_inplace(char *s) { 
    for (size_t i = 0; s[i] != '\0'; i++) {
        s[i] = ascii_tolower(s[i]); 
    }
}

char* create_upper_string(const char *s) {
    if (!s) return NULL;
    
    size_t len = strlen(s);
    char *result = mod_malloc(len + 1);
    if (!result) return NULL;
    
    for (size_t i = 0; i <= len; i++) {
        result[i] = ascii_toupper(s[i]);
    }
    
    return result;
}

char* create_lower_string(const char *s) {
    if (!s) return NULL;
    
    size_t len = strlen(s);
    char *result = mod_malloc(len + 1);
    if (!result) return NULL;
    
    for (size_t i = 0; i <= len; i++) {
        result[i] = ascii_tolower(s[i]);
    }
    
    return result;
}

char* create_trimmed_string(const char *s) {
    if (!s) return NULL;
    
    // Find start (skip leading whitespace)
    int start = 0;
    while (s[start] && ascii_isspace(s[start])) {
        start++;
    }
    
    // Find end (skip trailing whitespace)
    int end = start;
    while (s[end]) end++;
    while (end > start && ascii_isspace(s[end - 1])) {
        end--;
    }
    
    // Create trimmed string
    int len = end - start;
    char *result = mod_malloc(len + 1);
    if (!result) return NULL;
    
    for (int i = 0; i < len; i++) {
        result[i] = s[start + i];
    }
    result[len] = '\0';
    
    return result;
}

/* String utility functions */
int string_starts_with(const char *str, const char *prefix) {
    if (!str || !prefix) return 0;
    return strncmp(str, prefix, strlen(prefix)) == 0;
}

int string_ends_with(const char *str, const char *suffix) {
    if (!str || !suffix) return 0;
    
    size_t str_len = strlen(str);
    size_t suffix_len = strlen(suffix);
    
    if (suffix_len > str_len) return 0;
    
    return mod_strcmp(str + str_len - suffix_len, suffix) == 0;
}

int string_contains(const char *str, const char *substr) {
    if (!str || !substr) return 0;
    return strstr(str, substr) != NULL;
}

/* String parsing functions */
int string_parse_int(const char *str) {
    if (!str) return 0;
    return atoi(str);
}

int string_from_hex(const char *str) {
    if (!str) return 0;
    return (int)strtol(str, NULL, 16);
}

/* File I/O string functions */
int string_write_file(const char *filename, const char *content) {
    if (!filename || !content) return 0;
    
    FILE* file = fopen(filename, "w");
    if (!file) return 0;
    
    int success = (fputs(content, file) != EOF);
    fclose(file);
    return success;
}

int string_append_file(const char *filename, const char *content) {
    if (!filename || !content) return 0;
    
    FILE* file = fopen(filename, "a");
    if (!file) return 0;
    
    int success = (fputs(content, file) != EOF);
    fclose(file);
    return success;
}

int string_file_exists(const char *filename) {
    if (!filename) return 0;
    
    FILE* file = fopen(filename, "r");
    int exists = (file != NULL);
    if (file) fclose(file);
    return exists;
}
