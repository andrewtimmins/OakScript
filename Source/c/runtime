#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdint.h>

/* Fallback for uintptr_t if stdint does not provide it (Norcroft compatibility) */
#ifndef UINTPTR_MAX
typedef unsigned int uintptr_t;
#endif
#include "h.runtime"
#include "h.memory"
#include "h.strings"
#include "h.bridge"
#include "h.rt_objects"
#include "h.engine" /* for VarType, LambdaFunc */

/* ---- Debug line map & symbol table structures (file-scope) ---- */
typedef struct { int offset; int line; int col; int end_col; char snippet[64]; } dbg_line_entry_t;
typedef struct { int start; int end; int params; char name[64]; char param_list[128]; } sym_func_entry_t;
static dbg_line_entry_t *g_dbg_map = NULL; static int g_dbg_count = 0; static int g_dbg_cap = 0;
static sym_func_entry_t *g_sym_funcs = NULL; static int g_sym_count = 0; static int g_sym_cap = 0;
static const char* sym_lookup(int pc){ for(int i=0;i<g_sym_count;i++){ if(pc>=g_sym_funcs[i].start && pc<g_sym_funcs[i].end) return g_sym_funcs[i].name; } return NULL; }
static int dbg_lookup_line(int offset){ int lo=0, hi=g_dbg_count-1, best=0; while(lo<=hi){ int mid=(lo+hi)/2; int mo=g_dbg_map[mid].offset; if(mo==offset){ return g_dbg_map[mid].line; } if(mo<offset){ best=mid; lo=mid+1; } else hi=mid-1; } return g_dbg_count? g_dbg_map[best].line : 0; }
static void dbg_lookup_line_cols(int offset,int *out_line,int *out_col,int *out_end_col){ int lo=0, hi=g_dbg_count-1, best=0; while(lo<=hi){ int mid=(lo+hi)/2; int mo=g_dbg_map[mid].offset; if(mo==offset){ if(out_line) *out_line=g_dbg_map[mid].line; if(out_col) *out_col=g_dbg_map[mid].col; if(out_end_col) *out_end_col=g_dbg_map[mid].end_col; return; } if(mo<offset){ best=mid; lo=mid+1; } else hi=mid-1; } if(g_dbg_count){ if(out_line) *out_line=g_dbg_map[best].line; if(out_col) *out_col=g_dbg_map[best].col; if(out_end_col) *out_end_col=g_dbg_map[best].end_col; } }

/* Runtime variable storage */
#define MAX_RUNTIME_VARS 100

typedef enum {
    RT_VAR_INT,
    RT_VAR_FLOAT,
    RT_VAR_STRING,
    RT_VAR_HANDLE,
    RT_VAR_NULL
} runtime_var_type_t;

typedef struct {
    char name[64];
    runtime_var_type_t type;
    union {
        int int_value;
        float float_value;
        char *string_value;
        void *handle_ptr;
    } value;
    int is_used;
} runtime_variable_t;

static runtime_variable_t runtime_vars[MAX_RUNTIME_VARS];
static int runtime_var_count = 0;

/* Runtime stack for values */
#define MAX_STACK_SIZE 100
typedef struct {
    runtime_var_type_t type;
    union {
    int int_value;
    float float_value;
    char *string_value;
        void *handle_ptr;
    } value;
} stack_value_t;

/* Object registry for heap-managed structures */
typedef enum {
    OBJ_DICT = 1,
    OBJ_LIST,
    OBJ_SET,
    OBJ_REGEX,
    OBJ_OPTIONAL,
    OBJ_UNION,
    OBJ_COMPOSED,
    OBJ_PARTIAL,
    OBJ_MEMOIZE,
    OBJ_LAMBDA, /* interpreter lambda */
    OBJ_EXCEPTION
} rt_object_type_t;

typedef struct rt_object_header {
    int refcount;
    rt_object_type_t type;
    int freeing; /* sentinel to break recursive free cycles */
} rt_object_header_t;

/* Helper macro to initialize a newly allocated runtime object header */
#define INIT_OBJ_HDR(ptr, objtype) \
    do { \
        (ptr)->hdr.refcount = 1; \
        (ptr)->hdr.type = (objtype); \
        (ptr)->hdr.freeing = 0; \
    } while (0)

/* Optional runtime debug: define OAK_RT_DEBUG to get verbose leak diagnostics */
#ifdef OAK_RT_DEBUG
static void runtime_dump_registry(const char *label) {
    printf("[RTDBG] %s: object_count=%d\n", label, object_count);
    for (int i = 0; i < object_count; i++) {
        rt_object_header_t *h = (rt_object_header_t *)object_registry[i];
        const char *tn = "?";
        switch (h->type) {
            case OBJ_DICT: tn = "dict"; break; case OBJ_LIST: tn = "list"; break;
            case OBJ_SET: tn = "set"; break; case OBJ_REGEX: tn = "regex"; break;
            case OBJ_OPTIONAL: tn = "optional"; break; case OBJ_UNION: tn = "union"; break;
        }
        printf("[RTDBG] idx=%d ptr=%p type=%s ref=%d freeing=%d\n", i, (void*)h, tn, h->refcount, h->freeing);
    }
}
#else
#define runtime_dump_registry(label) do{}while(0)
#endif

typedef struct {
    char *key;
    stack_value_t value;
} rt_kv_t;

typedef struct {
    rt_object_header_t hdr;
    int size;
    int cap;
    rt_kv_t *items;
} rt_dict_t;

typedef struct {
    rt_object_header_t hdr;
    int size;
    int cap;
    stack_value_t *items;
} rt_list_t;

typedef struct {
    rt_object_header_t hdr;
    int size;
    int cap;
    stack_value_t *items; // unique by equals
} rt_set_t;

typedef struct {
    rt_object_header_t hdr;
    RegexPattern *rx;
    char *pattern;
} rt_regex_t;

typedef struct {
    rt_object_header_t hdr;
    int has_value;
    stack_value_t value;
} rt_optional_t;

typedef struct {
    rt_object_header_t hdr;
    char *tag;
    stack_value_t value;
} rt_union_t;

typedef struct {
    rt_object_header_t hdr;
    char *type_name;
    char *message;
    char *file_name;
    int line_number;
    char *stack_trace;
} rt_exception_t;

/* Functional composition / partial / memoize runtime objects */
typedef struct {
    rt_object_header_t hdr;
    void *f1; /* retained callable */
    void *f2; /* retained callable */
} rt_composed_t;

#define RT_PARTIAL_MAX 8
typedef struct {
    rt_object_header_t hdr;
    void *base; /* retained callable */
    int fixed_count;
    stack_value_t fixed[RT_PARTIAL_MAX];
} rt_partial_t;

typedef struct rt_memo_entry {
    unsigned int hash;
    int argc;
    stack_value_t *args; /* array length argc */
    stack_value_t result;
    struct rt_memo_entry *next;
} rt_memo_entry_t;

typedef struct {
    rt_object_header_t hdr;
    void *base; /* retained callable */
    int bucket_count;
    rt_memo_entry_t **buckets;
} rt_memoize_t;

/* Global runtime stack and variables */
static stack_value_t runtime_stack[MAX_STACK_SIZE];
static int stack_top = -1;

/* Forward declarations */
static void push_null(void);
static void free_value(stack_value_t *val);

#define MAX_OBJECTS 1024
static void *object_registry[MAX_OBJECTS];
static int object_count = 0;

/* Small helpers for bounds validation to avoid data aborts */
static inline int is_valid_pc(int addr, unsigned int code_size) {
    return (addr >= 0) && ((unsigned int)addr < code_size);
}

static inline int is_valid_cstring(const char *data_base, int data_size, int offset) {
    if (!data_base || data_size <= 0) return 0;
    if (offset < 0 || offset >= data_size) return 0;
    const char *p = data_base + offset;
    int remaining = data_size - offset;
    for (int i = 0; i < remaining; i++) {
        if (p[i] == '\0') return 1; // found terminator within bounds
    }
    return 0; // no terminator within data section
}

void registry_add(void *obj) {
    if (!obj) return;
    if (object_count < MAX_OBJECTS) {
        object_registry[object_count++] = obj;
    }
}
int rt_object_count_total(void) { return object_count; }
int rt_object_count_by_type(int type) {
    int c = 0;
    for (int i = 0; i < object_count; i++) {
        rt_object_header_t *h = (rt_object_header_t *)object_registry[i];
        if (h && h->type == type) c++;
    }
    return c;
}

static void registry_remove(void *obj) {
    if (!obj) return;
    for (int i = 0; i < object_count; i++) {
        if (object_registry[i] == obj) {
            object_registry[i] = object_registry[object_count - 1];
            object_count--;
            return;
        }
    }
}

/* Enumerate all registered runtime objects for diagnostics/auditing.
   Callback returns non-zero to continue, 0 to stop early. */
int rt_object_enumerate(int (*cb)(void *obj, int type, int refcount, void *ud), void *ud){
    if(!cb) return 0; for(int i=0;i<object_count;i++){ rt_object_header_t *h=(rt_object_header_t*)object_registry[i]; int cont = cb(object_registry[i], h? h->type : -1, h? h->refcount : -1, ud); if(!cont) break; } return object_count; }

static void retain_obj(void *obj) {
    if (!obj) return;
    rt_object_header_t *h = (rt_object_header_t *)obj;
    h->refcount++;
}

static void free_value_shallow(stack_value_t v);
static void free_value_deep(stack_value_t v);

static void release_obj(void *obj) {
    if (!obj) return;
    rt_object_header_t *h = (rt_object_header_t *)obj;
    h->refcount--;
    if (h->refcount > 0) return;
    if (h->freeing) return; /* already in free path */
    h->freeing = 1;
    // remove from registry
    registry_remove(obj);
    switch (h->type) {
        case OBJ_DICT: {
            rt_dict_t *d = (rt_dict_t *)obj;
            for (int i = 0; i < d->size; i++) {
                if (d->items[i].key) mod_free(d->items[i].key);
                free_value_deep(d->items[i].value);
            }
            if (d->items) mod_free(d->items);
            mod_free(d);
            break;
        }
        case OBJ_LIST: {
            rt_list_t *l = (rt_list_t *)obj;
            for (int i = 0; i < l->size; i++) free_value_deep(l->items[i]);
            if (l->items) mod_free(l->items);
            mod_free(l);
            break;
        }
        case OBJ_SET: {
            rt_set_t *s = (rt_set_t *)obj;
            for (int i = 0; i < s->size; i++) free_value_deep(s->items[i]);
            if (s->items) mod_free(s->items);
            mod_free(s);
            break;
        }
        case OBJ_REGEX: {
            rt_regex_t *r = (rt_regex_t *)obj;
            if (r->rx) regex_destroy(r->rx);
            if (r->pattern) mod_free(r->pattern);
            mod_free(r);
            break;
        }
        case OBJ_OPTIONAL: {
            rt_optional_t *o = (rt_optional_t *)obj;
            if (o->has_value) free_value_deep(o->value);
            mod_free(o);
            break;
        }
        case OBJ_UNION: {
            rt_union_t *u = (rt_union_t *)obj;
            if (u->tag) mod_free(u->tag);
            free_value_deep(u->value);
            mod_free(u);
            break;
        }
        case OBJ_EXCEPTION: {
            rt_exception_t *e = (rt_exception_t *)obj;
            if (e->type_name) mod_free(e->type_name);
            if (e->message) mod_free(e->message);
            if (e->file_name) mod_free(e->file_name);
            if (e->stack_trace) mod_free(e->stack_trace);
            mod_free(e);
            break;
        }
        case OBJ_COMPOSED: {
            rt_composed_t *c = (rt_composed_t *)obj;
            if (c->f1) release_obj(c->f1);
            if (c->f2) release_obj(c->f2);
            mod_free(c);
            break;
        }
        case OBJ_PARTIAL: {
            rt_partial_t *p = (rt_partial_t *)obj;
            if (p->base) release_obj(p->base);
            for (int i=0;i<p->fixed_count;i++) free_value_deep(p->fixed[i]);
            mod_free(p);
            break;
        }
        case OBJ_MEMOIZE: {
            rt_memoize_t *m = (rt_memoize_t *)obj;
            if (m->base) release_obj(m->base);
            if (m->buckets) {
                for (int bi=0; bi<m->bucket_count; bi++) {
                    rt_memo_entry_t *e = m->buckets[bi];
                    while (e) { rt_memo_entry_t *n = e->next; for (int ai=0; ai<e->argc; ai++) free_value_deep(e->args[ai]); if (e->args) mod_free(e->args); free_value_deep(e->result); mod_free(e); e = n; }
                }
                mod_free(m->buckets);
            }
            mod_free(m);
            break;
        }
        case OBJ_LAMBDA: {
            extern void lambda_destroy(struct LambdaFunc* func);
            lambda_destroy((struct LambdaFunc*)obj);
            break;
        }
        default:
            break;
    }
}

static int equals_value(stack_value_t a, stack_value_t b) {
    if (a.type != b.type) {
        // allow numeric cross-compare
        if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
            float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
            float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
            return fabsf(av - bv) < 1e-6f;
        }
        return 0;
    }
    switch (a.type) {
        case RT_VAR_INT: return a.value.int_value == b.value.int_value;
        case RT_VAR_FLOAT: return fabsf(a.value.float_value - b.value.float_value) < 1e-6f;
        case RT_VAR_STRING: return a.value.string_value && b.value.string_value && mod_strcmp(a.value.string_value, b.value.string_value) == 0;
        case RT_VAR_HANDLE: return a.value.handle_ptr == b.value.handle_ptr;
        case RT_VAR_NULL: return 1;
        default: return 0;
    }
}

static stack_value_t copy_value(stack_value_t v) {
    stack_value_t out = v;
    if (v.type == RT_VAR_STRING && v.value.string_value) {
        out.value.string_value = mod_strdup(v.value.string_value);
    } else if (v.type == RT_VAR_HANDLE && v.value.handle_ptr) {
        retain_obj(v.value.handle_ptr);
    }
    return out;
}

static void free_value_shallow(stack_value_t v) {
    if (v.type == RT_VAR_STRING && v.value.string_value) {
        mod_free(v.value.string_value);
    }
}

static void free_value_deep(stack_value_t v) {
    if (v.type == RT_VAR_STRING && v.value.string_value) {
        mod_free(v.value.string_value);
    } else if (v.type == RT_VAR_HANDLE && v.value.handle_ptr) {
        release_obj(v.value.handle_ptr);
    }
}

static void push_handle(void *obj) {
    if (!obj) { push_null(); return; }
    if (stack_top < MAX_STACK_SIZE - 1) {
        stack_top++;
        runtime_stack[stack_top].type = RT_VAR_HANDLE;
        runtime_stack[stack_top].value.handle_ptr = obj;
    }
}

/* Forward declarations for internal conversion helpers (defined earlier in file) */
static stack_value_t bridge_to_stack_value(const bridge_value_t *bv);
static void stack_value_to_bridge(stack_value_t sv, bridge_value_t *out);

/* ================= Functional (Batch5) ================= */
static unsigned int rt_hash_args(int argc, stack_value_t *args) {
    unsigned int h=5381; for (int i=0;i<argc;i++){ h = ((h<<5)+h) + args[i].type; switch(args[i].type){ case RT_VAR_INT: h=((h<<5)+h)+ (unsigned int)args[i].value.int_value; break; case RT_VAR_STRING: if(args[i].value.string_value){ const char *p=args[i].value.string_value; while(*p){ h=((h<<5)+h)+ (unsigned char)(*p++); } } break; default: h=((h<<5)+h)+ (unsigned int)(uintptr_t)args[i].value.handle_ptr; break; } } return h; }

void *rt_compose_create(void *f1, void *f2) {
    if (!f1 || !f2) return NULL; rt_composed_t *c = (rt_composed_t*)mod_malloc(sizeof(rt_composed_t)); if(!c) return NULL; INIT_OBJ_HDR(c, OBJ_COMPOSED); c->f1=f1; c->f2=f2; retain_obj(f1); retain_obj(f2); registry_add(c); return c; }

void *rt_partial_create(void *base, int argc, const bridge_value_t *argv) {
    if(!base) return NULL; if (argc < 0) argc=0; if (argc>RT_PARTIAL_MAX) argc = RT_PARTIAL_MAX; rt_partial_t *p = (rt_partial_t*)mod_malloc(sizeof(rt_partial_t)); if(!p) return NULL; INIT_OBJ_HDR(p, OBJ_PARTIAL); p->base=base; retain_obj(base); p->fixed_count=0; for(int i=0;i<argc;i++){ p->fixed[i] = bridge_to_stack_value(&argv[i]); p->fixed_count++; } registry_add(p); return p; }

void *rt_memoize_create(void *base) {
    if(!base) return NULL; rt_memoize_t *m = (rt_memoize_t*)mod_malloc(sizeof(rt_memoize_t)); if(!m) return NULL; INIT_OBJ_HDR(m, OBJ_MEMOIZE); m->base=base; retain_obj(base); m->bucket_count = 32; m->buckets = (rt_memo_entry_t**)mod_calloc(m->bucket_count, sizeof(rt_memo_entry_t*)); if(!m->buckets){ release_obj(base); mod_free(m); return NULL; } registry_add(m); return m; }

static int rt_callable_invoke_internal(void *callable, int argc, stack_value_t *sv_args, stack_value_t *sv_result);

int rt_callable_invoke(void *callable, int argc, bridge_value_t *argv, bridge_value_t *result) {
    if(!result) return 0; stack_value_t sv_args_local[16]; stack_value_t *sv_args = sv_args_local; if (argc>16){ sv_args = (stack_value_t*)mod_malloc(sizeof(stack_value_t)*argc); if(!sv_args) return 0; }
    for(int i=0;i<argc;i++){ sv_args[i] = bridge_to_stack_value(&argv[i]); }
    stack_value_t sv_out; sv_out.type = RT_VAR_NULL; if(!rt_callable_invoke_internal(callable, argc, sv_args, &sv_out)){ for(int i=0;i<argc;i++) free_value_deep(sv_args[i]); if(sv_args!=sv_args_local) mod_free(sv_args); return 0; }
    for(int i=0;i<argc;i++) free_value_deep(sv_args[i]); if(sv_args!=sv_args_local) mod_free(sv_args);
    stack_value_to_bridge(sv_out, result); free_value_deep(sv_out); return 1; }

/* Placeholder lambda execution: currently we cannot evaluate source body; treat lambda as identity of first arg */
/* Actual lambda invocation hook: integrate with advanced lambda implementation.
   We detect legacy lambda objects (OBJ_LAMBDA) produced by compiler/interpreter side
   and call into lambda_call_with_args. Fallback still identity if integration fails. */
extern void* lambda_call_with_args(struct LambdaFunc* func, void** args, VarType* arg_types, int arg_count); /* from c.functional */
extern struct LambdaFunc* get_lambda(int handle); /* if handles are used, optional */

static int invoke_lambda_identity(int argc, stack_value_t *args, stack_value_t *out){ if(argc>0){ *out = copy_value(args[0]); } else { out->type=RT_VAR_NULL; } return 1; }

static int invoke_lambda_object(rt_object_header_t *h, int argc, stack_value_t *sv_args, stack_value_t *sv_result) {
    if(!h) return invoke_lambda_identity(argc, sv_args, sv_result);
    if(h->type != OBJ_LAMBDA) return invoke_lambda_identity(argc, sv_args, sv_result);
    /* Layout assumption: h actually points to LambdaFunc since legacy system registers OBJ_LAMBDA with LambdaFunc* */
    struct LambdaFunc *lf = (struct LambdaFunc*)h; /* reinterpret */
    if(!lf) return invoke_lambda_identity(argc, sv_args, sv_result);
    if(argc > 16) argc = 16; /* safety clamp */
    void *arg_ptrs[16]; VarType arg_types[16];
    for(int i=0;i<argc;i++) {
        switch(sv_args[i].type){
            case RT_VAR_INT: arg_types[i]=VAR_INT; arg_ptrs[i]=&sv_args[i].value.int_value; break;
            case RT_VAR_FLOAT: arg_types[i]=VAR_FLOAT; arg_ptrs[i]=&sv_args[i].value.float_value; break;
            case RT_VAR_STRING: arg_types[i]=VAR_STRING; arg_ptrs[i]=sv_args[i].value.string_value; break;
            case RT_VAR_NULL: arg_types[i]=VAR_NULL; arg_ptrs[i]=NULL; break;
            case RT_VAR_HANDLE: arg_types[i]=VAR_POINTER; arg_ptrs[i]=sv_args[i].value.handle_ptr; break;
            default: arg_types[i]=VAR_NULL; arg_ptrs[i]=NULL; break;
        }
    }
    void *ret = lambda_call_with_args(lf, arg_ptrs, arg_types, argc);
    if(!ret){ sv_result->type = RT_VAR_NULL; return 1; }
    /* For now we assume integer return (improve when LambdaFunc stores return type) */
    sv_result->type = RT_VAR_INT; sv_result->value.int_value = *((int*)ret);
    mod_free(ret);
    return 1;
}

static rt_memo_entry_t *memo_lookup(rt_memoize_t *m, unsigned int hash, int argc, stack_value_t *args){ int bucket = hash % m->bucket_count; rt_memo_entry_t *e = m->buckets[bucket]; while(e){ if(e->hash==hash && e->argc==argc){ int match=1; for(int i=0;i<argc && match;i++){ if(!equals_value(e->args[i], args[i])) match=0; } if(match) return e; } e=e->next; } return NULL; }

static void memo_store(rt_memoize_t *m, unsigned int hash, int argc, stack_value_t *args, stack_value_t result){ int bucket = hash % m->bucket_count; rt_memo_entry_t *e = (rt_memo_entry_t*)mod_malloc(sizeof(rt_memo_entry_t)); if(!e) return; e->hash=hash; e->argc=argc; e->args=(stack_value_t*)mod_malloc(sizeof(stack_value_t)*argc); if(!e->args){ mod_free(e); return; } for(int i=0;i<argc;i++) e->args[i]=copy_value(args[i]); e->result = copy_value(result); e->next = m->buckets[bucket]; m->buckets[bucket]=e; }

static int rt_callable_invoke_internal(void *callable, int argc, stack_value_t *sv_args, stack_value_t *sv_result) {
    if(!callable){ sv_result->type=RT_VAR_NULL; return 1; }
    rt_object_header_t *h = (rt_object_header_t*)callable;
    switch(h->type){
        case OBJ_COMPOSED: {
            rt_composed_t *c = (rt_composed_t*)callable; stack_value_t mid; mid.type=RT_VAR_NULL; if(!rt_callable_invoke_internal(c->f2, argc, sv_args, &mid)) return 0; stack_value_t mid_args[1]; mid_args[0]=mid; int ok = rt_callable_invoke_internal(c->f1, 1, mid_args, sv_result); free_value_deep(mid); return ok; }
        case OBJ_PARTIAL: {
            rt_partial_t *p = (rt_partial_t*)callable; int total = p->fixed_count + argc; stack_value_t local[16]; stack_value_t *all = (total<=16)?local:(stack_value_t*)mod_malloc(sizeof(stack_value_t)*total); if(!all) return 0; int idx=0; for(int i=0;i<p->fixed_count;i++) all[idx++]=copy_value(p->fixed[i]); for(int j=0;j<argc;j++) all[idx++]=copy_value(sv_args[j]); int ok = rt_callable_invoke_internal(p->base, total, all, sv_result); for(int k=0;k<idx;k++) free_value_deep(all[k]); if(all!=local) mod_free(all); return ok; }
        case OBJ_MEMOIZE: {
            rt_memoize_t *m = (rt_memoize_t*)callable; unsigned int hash = rt_hash_args(argc, sv_args); rt_memo_entry_t *found = memo_lookup(m, hash, argc, sv_args); if(found){ *sv_result = copy_value(found->result); return 1; } int ok = rt_callable_invoke_internal(m->base, argc, sv_args, sv_result); if(ok) memo_store(m, hash, argc, sv_args, *sv_result); return ok; }
        case OBJ_LAMBDA: {
            return invoke_lambda_object(h, argc, sv_args, sv_result);
        }
        default: /* unknown callable type: treat as identity */ return invoke_lambda_identity(argc, sv_args, sv_result);
    }
}

void *rt_map(void *list_handle, void *callable) {
    if(!list_handle) return NULL; rt_object_header_t *h=(rt_object_header_t*)list_handle; if(h->type!=OBJ_LIST) return NULL; rt_list_t *in=(rt_list_t*)list_handle; rt_list_t *out=(rt_list_t*)rt_list_create(in->size); if(!out) return NULL; for(int i=0;i<in->size;i++){ stack_value_t sv = in->items[i]; stack_value_t arg = copy_value(sv); stack_value_t res; res.type=RT_VAR_NULL; if(!rt_callable_invoke_internal(callable, 1, &arg, &res)){ free_value_deep(arg); free_value_deep(res); continue; } free_value_deep(arg); /* add result */ bridge_value_t bv; stack_value_to_bridge(res,&bv); free_value_deep(res); rt_list_append(out,&bv); if(bv.type==BRIDGE_VAL_STRING && bv.data.s) mod_free(bv.data.s); }
    return out; }

void *rt_filter(void *list_handle, void *callable) {
    if(!list_handle) return NULL; rt_object_header_t *h=(rt_object_header_t*)list_handle; if(h->type!=OBJ_LIST) return NULL; rt_list_t *in=(rt_list_t*)list_handle; rt_list_t *out=(rt_list_t*)rt_list_create(in->size); if(!out) return NULL; for(int i=0;i<in->size;i++){ stack_value_t sv = in->items[i]; stack_value_t arg = copy_value(sv); stack_value_t res; res.type=RT_VAR_NULL; if(!rt_callable_invoke_internal(callable, 1, &arg, &res)){ free_value_deep(arg); free_value_deep(res); continue; } free_value_deep(arg); int truthy=0; if(res.type==RT_VAR_INT) truthy = (res.value.int_value!=0); else if(res.type==RT_VAR_FLOAT) truthy = (fabsf(res.value.float_value) > 1e-6f); else if(res.type==RT_VAR_STRING) truthy = (res.value.string_value && res.value.string_value[0]); else if(res.type==RT_VAR_HANDLE) truthy = (res.value.handle_ptr!=NULL); if(truthy){ bridge_value_t bv; stack_value_to_bridge(sv,&bv); rt_list_append(out,&bv); if(bv.type==BRIDGE_VAL_STRING && bv.data.s) mod_free(bv.data.s); } free_value_deep(res); }
    return out; }

int rt_reduce(void *list_handle, void *callable, const bridge_value_t *init, bridge_value_t *out){ if(out) { out->type=BRIDGE_VAL_NULL; out->owns=0; } if(!list_handle||!callable) return 0; rt_object_header_t *h=(rt_object_header_t*)list_handle; if(h->type!=OBJ_LIST) return 0; rt_list_t *in=(rt_list_t*)list_handle; stack_value_t acc; if(init){ acc = bridge_to_stack_value(init); } else { if(in->size==0){ return 1; } acc = copy_value(in->items[0]); }
    int start_index = (init)?0:1; for(int i=start_index;i<in->size;i++){ stack_value_t args[2]; args[0]=acc; args[1]=copy_value(in->items[i]); stack_value_t res; res.type=RT_VAR_NULL; if(!rt_callable_invoke_internal(callable,2,args,&res)){ free_value_deep(args[0]); free_value_deep(args[1]); free_value_deep(res); return 0; } free_value_deep(args[0]); free_value_deep(args[1]); acc = res; }
    if(out){ stack_value_to_bridge(acc,out); free_value_deep(acc); } else { free_value_deep(acc); }
    return 1; }

/* Minimal helper exposed to bridge for list_size (opaque outside) */
static void *current_exception_handle = NULL; /* rt_exception_t* retained while current */
/* Exception type registry */
typedef struct rt_exception_type_info {
    char *name;
    char *description;
    struct rt_exception_type_info *parent;
    struct rt_exception_type_info *next;
} rt_exception_type_info_t;
static rt_exception_type_info_t *rt_exception_types = NULL;

static rt_exception_type_info_t *rt_find_exc_type(const char *name){ rt_exception_type_info_t *c=rt_exception_types; while(c){ if(c->name && name && mod_strcmp(c->name,name)==0) return c; c=c->next; } return NULL; }

const char *rt_exception_description_for_type(const char *type){ rt_exception_type_info_t *t = rt_find_exc_type(type); return (t && t->description)? t->description : ""; }

int rt_exception_define(const char *type, const char *parent, const char *description){ if(!type) return 0; if(rt_find_exc_type(type)) return 1; rt_exception_type_info_t *info=(rt_exception_type_info_t*)mod_malloc(sizeof(rt_exception_type_info_t)); if(!info) return 0; info->name = mod_strdup(type); info->description = description?mod_strdup(description):mod_strdup(""); info->parent = parent? rt_find_exc_type(parent): NULL; info->next = rt_exception_types; rt_exception_types = info; return 1; }

int rt_exception_is_a(void *exc_handle, const char *type_name){ if(!exc_handle||!type_name) return 0; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return 0; rt_exception_t *e=(rt_exception_t*)exc_handle; rt_exception_type_info_t *exc_t = rt_find_exc_type(e->type_name); rt_exception_type_info_t *target = rt_find_exc_type(type_name); if(!exc_t||!target) return 0; for(rt_exception_type_info_t *cur=exc_t; cur; cur=cur->parent){ if(cur==target) return 1; } return 0; }

static void rt_exc_init_builtin_types(void){
    static int inited=0; if(inited) return; inited=1;
    rt_exception_define("Exception", NULL, "Base exception");
    rt_exception_define("RuntimeError", "Exception", "Runtime error");
    rt_exception_define("BuiltinError", "RuntimeError", "Builtin call failure");
    rt_exception_define("TypeError", "Exception", "Type error");
    rt_exception_define("ValueError", "Exception", "Value error");
    rt_exception_define("IndexError", "Exception", "Index out of range");
    rt_exception_define("KeyError", "Exception", "Key not found");
    rt_exception_define("FileError", "Exception", "File error");
    rt_exception_define("NetworkError", "Exception", "Network error");
    rt_exception_define("ParseError", "Exception", "Parse error");
    rt_exception_define("MemoryError", "Exception", "Memory error");
    rt_exception_define("DivisionByZero", "RuntimeError", "Division by zero");
    rt_exception_define("NullPointer", "RuntimeError", "Null pointer");
}

void *rt_exception_create(const char *type, const char *message, const char *file, int line) {
    rt_exc_init_builtin_types();
    if (!type) type = "Exception";
    rt_exception_t *e = (rt_exception_t*)mod_malloc(sizeof(rt_exception_t));
    if (!e) return NULL;
    INIT_OBJ_HDR(e, OBJ_EXCEPTION);
    e->type_name = mod_strdup(type);
    e->message = message ? mod_strdup(message) : mod_strdup("");
    e->file_name = file ? mod_strdup(file) : NULL;
    e->line_number = line;
    e->stack_trace = NULL;
    /* allocate empty stack trace (lazy) */
    /* We add stack_trace char* now: modify struct definition earlier? Already present? If not, we add at top of file. */
    registry_add(e);
    return e;
}

const char *rt_exception_type(void *exc_handle) {
    if(!exc_handle) return NULL; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return NULL; rt_exception_t *e=(rt_exception_t*)exc_handle; return e->type_name ? e->type_name : ""; }

const char *rt_exception_message(void *exc_handle) {
    if(!exc_handle) return NULL; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return NULL; rt_exception_t *e=(rt_exception_t*)exc_handle; return e->message ? e->message : ""; }

const char *rt_exception_description(void *exc_handle){ if(!exc_handle) return ""; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return ""; rt_exception_t *e=(rt_exception_t*)exc_handle; return rt_exception_description_for_type(e->type_name); }

int rt_exception_throw(void *exc_handle) {
    if(!exc_handle) return 0; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return 0; if(current_exception_handle) release_obj(current_exception_handle); retain_obj(exc_handle); current_exception_handle = exc_handle; /* Append initial frame with file:line if available */ rt_exception_t *e=(rt_exception_t*)exc_handle; if(e->file_name){ char frame[160]; int n = mod_snprintf(frame,sizeof(frame),"at %s:%d\n", e->file_name, e->line_number); if(n>0){ if(!e->stack_trace){ e->stack_trace = mod_strdup(frame); } else { int old_len = mod_strlen(e->stack_trace); int add_len = mod_strlen(frame); char *nt = (char*)mod_malloc(old_len+add_len+1); if(nt){ mod_strcpy(nt,e->stack_trace); mod_strcpy(nt+old_len, frame); mod_free(e->stack_trace); e->stack_trace=nt; } } } } return 1; }

void *rt_exception_current(void) { return current_exception_handle; }
char *rt_exception_stack_trace(void *exc_handle){ if(!exc_handle) return mod_strdup(""); rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return mod_strdup(""); rt_exception_t *e=(rt_exception_t*)exc_handle; if(e->stack_trace) return mod_strdup(e->stack_trace); /* fallback */ if(e->file_name){ char buf[256]; int n = mod_snprintf(buf,sizeof(buf),"at %s:%d", e->file_name, e->line_number); if(n>0) return mod_strdup(buf); } return mod_strdup(""); }
void rt_exception_add_frame(void *exc_handle, const char *function, const char *file, int line){ if(!exc_handle) return; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return; rt_exception_t *e=(rt_exception_t*)exc_handle; char frame[192]; if(function && file && line>0) { mod_snprintf(frame,sizeof(frame),"at %s (%s:%d)\n", function, file, line); }
 else if(function){ mod_snprintf(frame,sizeof(frame),"at %s\n", function); }
 else if(file && line>0){ mod_snprintf(frame,sizeof(frame),"at %s:%d\n", file, line); }
 else { return; }
 int add_len = mod_strlen(frame); if(add_len<=0) return; if(!e->stack_trace){ e->stack_trace = mod_strdup(frame); return; } int old_len = mod_strlen(e->stack_trace); char *nt = (char*)mod_malloc(old_len+add_len+1); if(!nt) return; mod_strcpy(nt,e->stack_trace); mod_strcpy(nt+old_len, frame); mod_free(e->stack_trace); e->stack_trace=nt; }
void rt_exception_add_frame_col(void *exc_handle, const char *function, const char *file, int line, int col, int end_col){ if(!exc_handle) return; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return; rt_exception_t *e=(rt_exception_t*)exc_handle; char frame[192]; if(function && file && line>0){ if(col>0){ if(end_col>col){ mod_snprintf(frame,sizeof(frame),"at %s (%s:%d:%d-%d)\n", function,file,line,col,end_col); } else { mod_snprintf(frame,sizeof(frame),"at %s (%s:%d:%d)\n", function,file,line,col); } } else { mod_snprintf(frame,sizeof(frame),"at %s (%s:%d)\n", function,file,line); } } else if(function && file){ mod_snprintf(frame,sizeof(frame),"at %s (%s)\n", function,file); } else if(function){ mod_snprintf(frame,sizeof(frame),"at %s\n", function); } else { return; } int add_len = mod_strlen(frame); if(add_len<=0) return; if(!e->stack_trace){ e->stack_trace = mod_strdup(frame); return; } int old_len = mod_strlen(e->stack_trace); char *nt=(char*)mod_malloc(old_len+add_len+1); if(!nt) return; mod_strcpy(nt,e->stack_trace); mod_strcpy(nt+old_len, frame); mod_free(e->stack_trace); e->stack_trace=nt; }
void rt_exception_clear_current(void){ if(current_exception_handle){ release_obj(current_exception_handle); current_exception_handle=NULL; } }
const char *rt_exception_file(void *exc_handle){ if(!exc_handle) return NULL; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return NULL; rt_exception_t *e=(rt_exception_t*)exc_handle; return e->file_name; }
int rt_exception_line(void *exc_handle){ if(!exc_handle) return 0; rt_object_header_t *h=(rt_object_header_t*)exc_handle; if(h->type!=OBJ_EXCEPTION) return 0; rt_exception_t *e=(rt_exception_t*)exc_handle; return e->line_number; }

int rt_try_call(void *try_callable, void *catch_callable, void *finally_callable, bridge_value_t *result){ if(result){ result->type=BRIDGE_VAL_NULL; result->owns=0; } if(!try_callable) return 0; bridge_value_t tmp_res; bridge_value_init(&tmp_res); int ok = rt_callable_invoke(try_callable, 0, NULL, &tmp_res); void *thrown = rt_exception_current(); if(thrown && catch_callable){ /* invoke catch with exception handle */ bridge_value_t arg; bridge_value_init(&arg); arg.type = BRIDGE_VAL_HANDLE; arg.data.handle = thrown; bridge_value_t catch_res; bridge_value_init(&catch_res); rt_callable_invoke(catch_callable, 1, &arg, &catch_res); bridge_value_free(&arg); if(result) *result = catch_res; else bridge_value_free(&catch_res); rt_exception_clear_current(); } else { if(result) *result = tmp_res; else bridge_value_free(&tmp_res); }
 if(finally_callable){ bridge_value_t fin_res; bridge_value_init(&fin_res); rt_callable_invoke(finally_callable,0,NULL,&fin_res); bridge_value_free(&fin_res); }
 return ok?1:0; }
int runtime_list_size(void *handle) {
    if (!handle) return 0;
    rt_object_header_t *h = (rt_object_header_t *)handle;
    if (h->type != OBJ_LIST) return 0;
    rt_list_t *l = (rt_list_t *)handle;
    return l->size;
}

int runtime_dict_size(void *handle) {
    if (!handle) return 0;
    rt_object_header_t *h = (rt_object_header_t *)handle;
    if (h->type != OBJ_DICT) return 0;
    rt_dict_t *d = (rt_dict_t *)handle;
    return d->size;
}

int runtime_set_size(void *handle) {
    if (!handle) return 0;
    rt_object_header_t *h = (rt_object_header_t *)handle;
    if (h->type != OBJ_SET) return 0;
    rt_set_t *s = (rt_set_t *)handle;
    return s->size;
}

int runtime_dict_has(void *handle, const char *key) {
    if (!handle || !key) return 0;
    rt_object_header_t *h = (rt_object_header_t *)handle;
    if (h->type != OBJ_DICT) return 0;
    rt_dict_t *d = (rt_dict_t *)handle;
    for (int i = 0; i < d->size; i++) {
        if (d->items[i].key && mod_strcmp(d->items[i].key, key) == 0) return 1;
    }
    return 0;
}

/* ================= rt_objects wrapper layer ================= */
static stack_value_t bridge_to_stack_value(const bridge_value_t *bv) {
    stack_value_t v; v.type = RT_VAR_NULL; v.value.int_value = 0;
    if (!bv) return v;
    switch (bv->type) {
        case BRIDGE_VAL_INT: v.type = RT_VAR_INT; v.value.int_value = bv->data.i; break;
        case BRIDGE_VAL_FLOAT: v.type = RT_VAR_FLOAT; v.value.float_value = bv->data.f; break;
        case BRIDGE_VAL_STRING: v.type = RT_VAR_STRING; v.value.string_value = bv->data.s ? mod_strdup(bv->data.s) : NULL; break;
        case BRIDGE_VAL_HANDLE: v.type = RT_VAR_HANDLE; v.value.handle_ptr = bv->data.handle; if (bv->data.handle) retain_obj(bv->data.handle); break;
        case BRIDGE_VAL_NULL: default: v.type = RT_VAR_NULL; break;
    }
    return v;
}

static void stack_value_to_bridge(stack_value_t sv, bridge_value_t *out) {
    if (!out) return; out->type = BRIDGE_VAL_NULL; out->owns = 0; out->data.i = 0;
    switch (sv.type) {
        case RT_VAR_INT: out->type = BRIDGE_VAL_INT; out->data.i = sv.value.int_value; break;
        case RT_VAR_FLOAT: out->type = BRIDGE_VAL_FLOAT; out->data.f = sv.value.float_value; break;
        case RT_VAR_STRING: out->type = BRIDGE_VAL_STRING; out->data.s = sv.value.string_value ? mod_strdup(sv.value.string_value) : NULL; out->owns = (out->data.s != NULL); break;
        case RT_VAR_HANDLE: out->type = BRIDGE_VAL_HANDLE; out->data.handle = sv.value.handle_ptr; if (sv.value.handle_ptr) retain_obj(sv.value.handle_ptr); break;
        case RT_VAR_NULL: default: out->type = BRIDGE_VAL_NULL; break;
    }
}

void *rt_list_create(int initial_cap) {
    if (initial_cap <= 0) initial_cap = 8;
    rt_list_t *l = (rt_list_t *)mod_malloc(sizeof(rt_list_t));
    if (!l) return NULL; INIT_OBJ_HDR(l, OBJ_LIST);
    l->size = 0; l->cap = initial_cap;
    l->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * l->cap);
    if (!l->items) { mod_free(l); return NULL; }
    registry_add(l);
    return l;
}

int rt_list_append(void *list_handle, const bridge_value_t *val) {
    if (!list_handle || !val) return 0; rt_list_t *l = (rt_list_t *)list_handle;
    if (l->hdr.type != OBJ_LIST) return 0;
    if (l->size >= l->cap) {
        int new_cap = l->cap * 2;
        stack_value_t *ni = (stack_value_t *)mod_realloc(l->items, sizeof(stack_value_t) * new_cap);
        if (!ni) return 0; l->items = ni; l->cap = new_cap;
    }
    stack_value_t sv = bridge_to_stack_value(val);
    l->items[l->size++] = sv;
    return 1;
}

int rt_list_get(void *list_handle, int index, bridge_value_t *out) {
    if (!list_handle || !out) return 0; rt_list_t *l = (rt_list_t *)list_handle;
    if (l->hdr.type != OBJ_LIST) return 0;
    if (index < 0 || index >= l->size) return 0;
    stack_value_to_bridge(l->items[index], out);
    return 1;
}

void *rt_dict_create(int initial_cap) {
    if (initial_cap <= 0) initial_cap = 8;
    rt_dict_t *d = (rt_dict_t *)mod_malloc(sizeof(rt_dict_t));
    if (!d) return NULL; INIT_OBJ_HDR(d, OBJ_DICT);
    d->size = 0; d->cap = initial_cap;
    d->items = (rt_kv_t *)mod_malloc(sizeof(rt_kv_t) * d->cap);
    if (!d->items) { mod_free(d); return NULL; }
    registry_add(d);
    return d;
}

static int dict_expand(rt_dict_t *d) {
    int new_cap = d->cap * 2;
    rt_kv_t *ni = (rt_kv_t *)mod_realloc(d->items, sizeof(rt_kv_t) * new_cap);
    if (!ni) return 0; d->items = ni; d->cap = new_cap; return 1;
}

int rt_dict_set(void *dict_handle, const char *key, const bridge_value_t *val) {
    if (!dict_handle || !key || !val) return 0; rt_dict_t *d = (rt_dict_t *)dict_handle;
    if (d->hdr.type != OBJ_DICT) return 0;
    for (int i = 0; i < d->size; i++) {
        if (d->items[i].key && mod_strcmp(d->items[i].key, key) == 0) {
            free_value_deep(d->items[i].value);
            d->items[i].value = bridge_to_stack_value(val);
            return 1;
        }
    }
    if (d->size >= d->cap) { if (!dict_expand(d)) return 0; }
    d->items[d->size].key = mod_strdup(key);
    d->items[d->size].value = bridge_to_stack_value(val);
    d->size++;
    return 1;
}

int rt_dict_get(void *dict_handle, const char *key, bridge_value_t *out) {
    if (!dict_handle || !key || !out) return 0; rt_dict_t *d = (rt_dict_t *)dict_handle;
    if (d->hdr.type != OBJ_DICT) return 0;
    for (int i = 0; i < d->size; i++) {
        if (d->items[i].key && mod_strcmp(d->items[i].key, key) == 0) {
            stack_value_to_bridge(d->items[i].value, out); return 1;
        }
    }
    return 0;
}

int rt_dict_remove(void *dict_handle, const char *key) {
    if (!dict_handle || !key) return 0; rt_dict_t *d = (rt_dict_t *)dict_handle;
    if (d->hdr.type != OBJ_DICT) return 0;
    for (int i = 0; i < d->size; i++) {
        if (d->items[i].key && mod_strcmp(d->items[i].key, key) == 0) {
            if (d->items[i].key) mod_free(d->items[i].key);
            free_value_deep(d->items[i].value);
            d->items[i] = d->items[d->size - 1];
            d->size--;
            return 1;
        }
    }
    return 0;
}

void *rt_dict_keys(void *dict_handle) {
    if (!dict_handle) return NULL; rt_dict_t *d = (rt_dict_t *)dict_handle;
    if (d->hdr.type != OBJ_DICT) return NULL;
    rt_list_t *l = (rt_list_t *)rt_list_create(d->size > 0 ? d->size : 1);
    if (!l) return NULL;
    for (int i = 0; i < d->size; i++) {
        bridge_value_t tmp; bridge_value_init(&tmp); tmp.type = BRIDGE_VAL_STRING; tmp.data.s = d->items[i].key; tmp.owns = 0; /* alias */
        rt_list_append(l, &tmp);
    }
    return l;
}

void *rt_set_create(int initial_cap) {
    if (initial_cap <= 0) initial_cap = 8;
    rt_set_t *s = (rt_set_t *)mod_malloc(sizeof(rt_set_t));
    if (!s) return NULL; INIT_OBJ_HDR(s, OBJ_SET);
    s->size = 0; s->cap = initial_cap;
    s->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * s->cap);
    if (!s->items) { mod_free(s); return NULL; }
    registry_add(s);
    return s;
}

int rt_set_add(void *set_handle, const bridge_value_t *val) {
    if (!set_handle || !val) return 0; rt_set_t *s = (rt_set_t *)set_handle;
    if (s->hdr.type != OBJ_SET) return 0;
    stack_value_t sv = bridge_to_stack_value(val);
    // Check duplicates (basic equality)
    for (int i = 0; i < s->size; i++) {
        if (equals_value(s->items[i], sv)) { free_value_shallow(sv); return 1; }
    }
    if (s->size >= s->cap) {
        int new_cap = s->cap * 2;
        stack_value_t *ni = (stack_value_t *)mod_realloc(s->items, sizeof(stack_value_t) * new_cap);
        if (!ni) { free_value_deep(sv); return 0; }
        s->items = ni; s->cap = new_cap;
    }
    s->items[s->size++] = sv;
    return 1;
}

int rt_set_contains(void *set_handle, const bridge_value_t *val) {
    if (!set_handle || !val) return 0; rt_set_t *s = (rt_set_t *)set_handle;
    if (s->hdr.type != OBJ_SET) return 0;
    bridge_value_t tmpbv; bridge_value_init(&tmpbv); /* convert for comparison */
    stack_value_t sv = bridge_to_stack_value(val);
    int found = 0;
    for (int i = 0; i < s->size && !found; i++) {
        if (equals_value(s->items[i], sv)) found = 1;
    }
    free_value_deep(sv);
    return found;
}

/* ================= Regex / Interpolation wrappers ================= */
void *rt_regex_create(const char *pattern, int flags) {
    (void)flags; /* flags unused in current simplified engine */
    if (!pattern) return NULL;
    rt_regex_t *r = (rt_regex_t *)mod_malloc(sizeof(rt_regex_t));
    if (!r) return NULL; INIT_OBJ_HDR(r, OBJ_REGEX);
    r->pattern = mod_strdup(pattern);
    r->rx = regex_compile(pattern, 0);
    if (!r->pattern || !r->rx) { if (r->pattern) mod_free(r->pattern); if (r->rx) regex_destroy(r->rx); mod_free(r); return NULL; }
    registry_add(r); return r;
}

int rt_regex_match(void *regex_handle, const char *text) {
    if (!regex_handle || !text) return 0; rt_regex_t *r = (rt_regex_t *)regex_handle;
    if (r->hdr.type != OBJ_REGEX || !r->rx) return 0; return regex_match(r->rx, text) ? 1 : 0;
}

char *rt_regex_replace(void *regex_handle, const char *text, const char *replacement) {
    if (!regex_handle || !text || !replacement) return NULL; rt_regex_t *r = (rt_regex_t *)regex_handle;
    if (r->hdr.type != OBJ_REGEX || !r->rx) return NULL; return regex_replace(r->rx, text, replacement);
}

char *rt_interpolate_template(const char *template_str) {
    if (!template_str) return NULL; InterpolatedString *istr = parse_interpolated_string(template_str);
    if (!istr) return NULL; char *res = evaluate_interpolated_string(istr); interpolated_string_destroy(istr); return res; }

char *rt_multiline_process(const char *raw_str) {
    if (!raw_str) return NULL; MultilineString *m = multiline_create(raw_str); if (!m) return mod_strdup(raw_str);
    char *out = multiline_to_string(m); multiline_destroy(m); return out; }

/* ================= Optional / Union / Type wrappers ================= */
void *rt_optional_create(const bridge_value_t *maybe_val) {
    rt_optional_t *o = (rt_optional_t *)mod_malloc(sizeof(rt_optional_t)); if (!o) return NULL; INIT_OBJ_HDR(o, OBJ_OPTIONAL);
    if (maybe_val && maybe_val->type != BRIDGE_VAL_NULL) {
        o->has_value = 1; bridge_value_t bv = *maybe_val; /* copy through conversion */
        stack_value_t sv = bridge_to_stack_value(&bv);
        o->value = sv;
    } else { o->has_value = 0; o->value.type = RT_VAR_NULL; }
    registry_add(o); return o; }

int rt_optional_has_value(void *opt_handle) {
    if (!opt_handle) return 0; rt_optional_t *o = (rt_optional_t*)opt_handle; if (o->hdr.type != OBJ_OPTIONAL) return 0; return o->has_value ? 1 : 0; }

int rt_optional_get(void *opt_handle, bridge_value_t *out) {
    if (!opt_handle || !out) return 0; rt_optional_t *o = (rt_optional_t*)opt_handle; if (o->hdr.type != OBJ_OPTIONAL || !o->has_value) return 0; stack_value_to_bridge(o->value, out); return 1; }

void *rt_union_create(const char *tag, const bridge_value_t *val) {
    if (!tag) return NULL; rt_union_t *u = (rt_union_t *)mod_malloc(sizeof(rt_union_t)); if (!u) return NULL; INIT_OBJ_HDR(u, OBJ_UNION);
    u->tag = mod_strdup(tag);
    if (val) { stack_value_t sv = bridge_to_stack_value(val); u->value = sv; } else { u->value.type = RT_VAR_NULL; }
    registry_add(u); return u; }

int rt_union_set(void *union_handle, const char *tag, const bridge_value_t *val) {
    if (!union_handle || !tag) return 0; rt_union_t *u = (rt_union_t*)union_handle; if (u->hdr.type != OBJ_UNION) return 0;
    if (u->tag) mod_free(u->tag); u->tag = mod_strdup(tag);
    free_value_deep(u->value); if (val) { u->value = bridge_to_stack_value(val); } else { u->value.type = RT_VAR_NULL; }
    return 1; }

int rt_union_get(void *union_handle, bridge_value_t *out) {
    if (!union_handle || !out) return 0; rt_union_t *u = (rt_union_t*)union_handle; if (u->hdr.type != OBJ_UNION) return 0; stack_value_to_bridge(u->value, out); return 1; }

const char *rt_union_tag(void *union_handle) {
    if (!union_handle) return NULL; rt_union_t *u = (rt_union_t*)union_handle; if (u->hdr.type != OBJ_UNION) return NULL; return u->tag; }

/* runtime_typeof_stack removed (unused) */

const char *rt_typeof_value(const bridge_value_t *v) {
    if (!v) return "unknown"; switch (v->type) {
        case BRIDGE_VAL_INT: return "int"; case BRIDGE_VAL_FLOAT: return "float"; case BRIDGE_VAL_STRING: return "string"; case BRIDGE_VAL_NULL: return "null"; case BRIDGE_VAL_HANDLE: default: {
            if (!v->data.handle) return "handle"; rt_object_header_t *h = (rt_object_header_t*)v->data.handle;
            switch (h->type) { case OBJ_DICT: return "dict"; case OBJ_LIST: return "list"; case OBJ_SET: return "set"; case OBJ_REGEX: return "regex"; case OBJ_OPTIONAL: return "optional"; case OBJ_UNION: return "union"; default: return "handle"; }
        } }
}

int rt_is_type(const bridge_value_t *v, const char *type_name) {
    if (!v || !type_name) return 0; const char *tn = rt_typeof_value(v); return mod_strcmp(tn, type_name) == 0 ? 1 : 0; }

int rt_is_null(const bridge_value_t *v) { return (!v || v->type == BRIDGE_VAL_NULL) ? 1 : 0; }

int rt_cast_value(const bridge_value_t *src, const char *target_type, bridge_value_t *out) {
    if (!src || !target_type || !out) return 0; bridge_value_init(out);
    if (mod_strcmp(target_type, "int") == 0) {
        if (src->type == BRIDGE_VAL_INT) { out->type = BRIDGE_VAL_INT; out->data.i = src->data.i; return 1; }
        if (src->type == BRIDGE_VAL_FLOAT) { out->type = BRIDGE_VAL_INT; out->data.i = (int)src->data.f; return 1; }
        if (src->type == BRIDGE_VAL_STRING && src->data.s) { /* naive parse */ int val = 0; const char *p = src->data.s; int sign=1; if (*p=='-'){sign=-1;p++;} while (*p && *p>='0'&&*p<='9'){ val = val*10 + (*p-'0'); p++; } out->type=BRIDGE_VAL_INT; out->data.i = sign*val; return 1; }
        return 0;
    } else if (mod_strcmp(target_type, "float") == 0) {
        if (src->type == BRIDGE_VAL_FLOAT) { out->type = BRIDGE_VAL_FLOAT; out->data.f = src->data.f; return 1; }
        if (src->type == BRIDGE_VAL_INT) { out->type = BRIDGE_VAL_FLOAT; out->data.f = (float)src->data.i; return 1; }
        return 0;
    } else if (mod_strcmp(target_type, "string") == 0) {
        char buf[64]; buf[0]='\0';
        if (src->type == BRIDGE_VAL_STRING) { out->type = BRIDGE_VAL_STRING; out->data.s = src->data.s ? mod_strdup(src->data.s) : mod_strdup(""); out->owns = 1; return 1; }
    if (src->type == BRIDGE_VAL_INT) { mod_itoa(src->data.i, buf); out->type=BRIDGE_VAL_STRING; out->data.s = mod_strdup(buf); out->owns=1; return 1; }
    if (src->type == BRIDGE_VAL_FLOAT) { mod_ftoa(src->data.f, buf, 6); out->type=BRIDGE_VAL_STRING; out->data.s = mod_strdup(buf); out->owns=1; return 1; }
        return 0;
    }
    return 0;
}

/* Call frame stack */
#define MAX_CALL_DEPTH 64
typedef struct {
    int return_pc;
    int stack_marker; // stack_top at call time (before args evaluation)
    runtime_variable_t locals[MAX_RUNTIME_VARS];
    int local_count;
} call_frame_t;

static call_frame_t call_stack[MAX_CALL_DEPTH];
static int call_top = -1;

/* Try/catch stack for exceptions */
#define MAX_TRY_DEPTH 128
typedef struct {
    int handler_pc;
    int call_top_at_try;
    int stack_top_at_try;
} try_entry_t;

static try_entry_t try_stack[MAX_TRY_DEPTH];
static int try_top = -1;

/* Stack operations */
static void push_int(int value) {
    if (stack_top < MAX_STACK_SIZE - 1) {
        stack_top++;
        runtime_stack[stack_top].type = RT_VAR_INT;
        runtime_stack[stack_top].value.int_value = value;
    }
}

static void push_float(float value) {
    if (stack_top < MAX_STACK_SIZE - 1) {
        stack_top++;
        runtime_stack[stack_top].type = RT_VAR_FLOAT;
        runtime_stack[stack_top].value.float_value = value;
    }
}

static void push_string(const char *value) {
    if (stack_top < MAX_STACK_SIZE - 1) {
        stack_top++;
        runtime_stack[stack_top].type = RT_VAR_STRING;
        // Add null check for safety
        if (value) {
            runtime_stack[stack_top].value.string_value = mod_strdup(value);
        } else {
            runtime_stack[stack_top].value.string_value = mod_strdup("");
        }
    }
}

static void push_null(void) {
    if (stack_top < MAX_STACK_SIZE - 1) {
        stack_top++;
        runtime_stack[stack_top].type = RT_VAR_NULL;
        runtime_stack[stack_top].value.int_value = 0;
    }
}

static stack_value_t pop_value() {
    stack_value_t result = {RT_VAR_INT, {0}};
    if (stack_top >= 0) {
        result = runtime_stack[stack_top];
        stack_top--;
    }
    return result;
}

static int get_truth_value(stack_value_t val) {
    switch (val.type) {
        case RT_VAR_INT:
            return val.value.int_value != 0;
        case RT_VAR_FLOAT:
            return val.value.float_value != 0.0f;
        case RT_VAR_STRING:
            return val.value.string_value != NULL && *val.value.string_value != '\0';
        case RT_VAR_HANDLE:
            return val.value.handle_ptr != NULL;
        case RT_VAR_NULL:
        default:
            return 0;
    }
}

static void free_value(stack_value_t *val) {
    if (!val) return;
    if (val->type == RT_VAR_STRING && val->value.string_value) {
        mod_free(val->value.string_value);
        val->value.string_value = NULL;
    } else if (val->type == RT_VAR_HANDLE && val->value.handle_ptr) {
        release_obj(val->value.handle_ptr);
        val->value.handle_ptr = NULL;
    }
    val->type = RT_VAR_NULL;
}

/* Variable operations */
static void store_variable(const char *name, stack_value_t value) {
    // If inside a function, store to current frame's locals
    if (call_top >= 0) {
        call_frame_t *frame = &call_stack[call_top];
        for (int i = 0; i < frame->local_count; i++) {
            if (frame->locals[i].is_used && mod_strcmp(frame->locals[i].name, name) == 0) {
                if (frame->locals[i].type == RT_VAR_STRING && frame->locals[i].value.string_value) {
                    mod_free(frame->locals[i].value.string_value);
                }
                if (frame->locals[i].type == RT_VAR_HANDLE && frame->locals[i].value.handle_ptr) {
                    release_obj(frame->locals[i].value.handle_ptr);
                }
                frame->locals[i].type = value.type;
                if (value.type == RT_VAR_INT) frame->locals[i].value.int_value = value.value.int_value;
                else if (value.type == RT_VAR_FLOAT) frame->locals[i].value.float_value = value.value.float_value;
                else if (value.type == RT_VAR_STRING) frame->locals[i].value.string_value = value.value.string_value;
                else if (value.type == RT_VAR_HANDLE) { frame->locals[i].value.handle_ptr = value.value.handle_ptr; retain_obj(value.value.handle_ptr); }
                else /* NULL */ frame->locals[i].value.int_value = 0;
                return;
            }
        }
        if (frame->local_count < MAX_RUNTIME_VARS) {
            mod_strcpy(frame->locals[frame->local_count].name, name);
            frame->locals[frame->local_count].type = value.type;
            if (value.type == RT_VAR_INT) frame->locals[frame->local_count].value.int_value = value.value.int_value;
            else if (value.type == RT_VAR_FLOAT) frame->locals[frame->local_count].value.float_value = value.value.float_value;
            else if (value.type == RT_VAR_STRING) frame->locals[frame->local_count].value.string_value = value.value.string_value;
            else if (value.type == RT_VAR_HANDLE) { frame->locals[frame->local_count].value.handle_ptr = value.value.handle_ptr; retain_obj(value.value.handle_ptr); }
            else frame->locals[frame->local_count].value.int_value = 0;
            frame->locals[frame->local_count].is_used = 1;
            frame->local_count++;
            return;
        } else {
            printf("Runtime error: Too many local variables\n");
            return;
        }
    }
    // Look for existing variable
    for (int i = 0; i < runtime_var_count; i++) {
        if (runtime_vars[i].is_used && mod_strcmp(runtime_vars[i].name, name) == 0) {
            // Free old string value if necessary
            if (runtime_vars[i].type == RT_VAR_STRING && runtime_vars[i].value.string_value) {
                mod_free(runtime_vars[i].value.string_value);
            }
            if (runtime_vars[i].type == RT_VAR_HANDLE && runtime_vars[i].value.handle_ptr) {
                release_obj(runtime_vars[i].value.handle_ptr);
            }
            
            // Update variable
            runtime_vars[i].type = value.type;
            if (value.type == RT_VAR_INT) runtime_vars[i].value.int_value = value.value.int_value;
            else if (value.type == RT_VAR_FLOAT) runtime_vars[i].value.float_value = value.value.float_value;
            else if (value.type == RT_VAR_STRING) runtime_vars[i].value.string_value = value.value.string_value;
            else if (value.type == RT_VAR_HANDLE) { runtime_vars[i].value.handle_ptr = value.value.handle_ptr; retain_obj(value.value.handle_ptr); }
            else runtime_vars[i].value.int_value = 0;
            return;
        }
    }
    
    // Create new variable
    if (runtime_var_count < MAX_RUNTIME_VARS) {
        mod_strcpy(runtime_vars[runtime_var_count].name, name);
        runtime_vars[runtime_var_count].type = value.type;
    if (value.type == RT_VAR_INT) runtime_vars[runtime_var_count].value.int_value = value.value.int_value;
    else if (value.type == RT_VAR_FLOAT) runtime_vars[runtime_var_count].value.float_value = value.value.float_value;
    else if (value.type == RT_VAR_STRING) runtime_vars[runtime_var_count].value.string_value = value.value.string_value;
    else if (value.type == RT_VAR_HANDLE) { runtime_vars[runtime_var_count].value.handle_ptr = value.value.handle_ptr; retain_obj(value.value.handle_ptr); }
        else runtime_vars[runtime_var_count].value.int_value = 0;
        runtime_vars[runtime_var_count].is_used = 1;
        runtime_var_count++;
    } else {
        printf("Runtime error: Too many variables\n");
    }
}

/* Bridge function for string interpolation - allows access to runtime variables */
void* runtime_get_variable_value(const char *name, VarType *type) {
    // Search locals from innermost frame outward
    if (call_top >= 0) {
        for (int f = call_top; f >= 0; f--) {
            call_frame_t *frame = &call_stack[f];
            for (int i = 0; i < frame->local_count; i++) {
                if (frame->locals[i].is_used && mod_strcmp(frame->locals[i].name, name) == 0) {
                    switch (frame->locals[i].type) {
                        case RT_VAR_INT:
                            *type = VAR_INT;
                            return &frame->locals[i].value.int_value;
                        case RT_VAR_FLOAT:
                            *type = VAR_FLOAT;
                            return &frame->locals[i].value.float_value;
                        case RT_VAR_STRING:
                            *type = VAR_STRING;
                            return frame->locals[i].value.string_value;
                        case RT_VAR_HANDLE:
                            *type = VAR_POINTER;
                            return frame->locals[i].value.handle_ptr;
                        default:
                            *type = VAR_INT;
                            return NULL;
                    }
                }
            }
        }
    }
    
    // Search global runtime variables
    for (int i = 0; i < runtime_var_count; i++) {
        if (runtime_vars[i].is_used && mod_strcmp(runtime_vars[i].name, name) == 0) {
            switch (runtime_vars[i].type) {
                case RT_VAR_INT:
                    *type = VAR_INT;
                    return &runtime_vars[i].value.int_value;
                case RT_VAR_FLOAT:
                    *type = VAR_FLOAT;
                    return &runtime_vars[i].value.float_value;
                case RT_VAR_STRING:
                    *type = VAR_STRING;
                    return runtime_vars[i].value.string_value;
                case RT_VAR_HANDLE:
                    *type = VAR_POINTER;
                    return runtime_vars[i].value.handle_ptr;
                default:
                    *type = VAR_INT;
                    return NULL;
            }
        }
    }
    
    return NULL; // Variable not found
}

/* Removed unused store_builtin_function (legacy helper) */

static void load_variable(const char *name) {
    // Search locals from innermost frame outward
    if (call_top >= 0) {
        for (int f = call_top; f >= 0; f--) {
            call_frame_t *frame = &call_stack[f];
            for (int i = 0; i < frame->local_count; i++) {
                if (frame->locals[i].is_used && mod_strcmp(frame->locals[i].name, name) == 0) {
                    if (frame->locals[i].type == RT_VAR_INT) push_int(frame->locals[i].value.int_value);
                    else if (frame->locals[i].type == RT_VAR_FLOAT) push_float(frame->locals[i].value.float_value);
                    else if (frame->locals[i].type == RT_VAR_STRING) push_string(frame->locals[i].value.string_value);
                    else if (frame->locals[i].type == RT_VAR_HANDLE) { push_handle(frame->locals[i].value.handle_ptr); }
                    else push_null();
                    return;
                }
            }
        }
    }
    for (int i = 0; i < runtime_var_count; i++) {
        if (runtime_vars[i].is_used && mod_strcmp(runtime_vars[i].name, name) == 0) {
            if (runtime_vars[i].type == RT_VAR_INT) push_int(runtime_vars[i].value.int_value);
            else if (runtime_vars[i].type == RT_VAR_FLOAT) push_float(runtime_vars[i].value.float_value);
            else if (runtime_vars[i].type == RT_VAR_STRING) push_string(runtime_vars[i].value.string_value);
            else if (runtime_vars[i].type == RT_VAR_HANDLE) { push_handle(runtime_vars[i].value.handle_ptr); }
            else push_null();
            return;
        }
    }
    
    // Variable not found - push default value
    printf("Runtime warning: Variable '%s' not found, using default\n", name);
    push_null();
}

static void cleanup_runtime_vars() {
    // Free locals in any remaining frames
    for (int f = call_top; f >= 0; f--) {
        for (int i = 0; i < call_stack[f].local_count; i++) {
            if (call_stack[f].locals[i].is_used) {
                if (call_stack[f].locals[i].type == RT_VAR_STRING && call_stack[f].locals[i].value.string_value) {
                    mod_free(call_stack[f].locals[i].value.string_value);
                    call_stack[f].locals[i].value.string_value = NULL;
                } else if (call_stack[f].locals[i].type == RT_VAR_HANDLE && call_stack[f].locals[i].value.handle_ptr) {
                    release_obj(call_stack[f].locals[i].value.handle_ptr);
                    call_stack[f].locals[i].value.handle_ptr = NULL;
                }
            }
            call_stack[f].locals[i].is_used = 0;
        }
        call_stack[f].local_count = 0;
    }
    call_top = -1;
    for (int i = 0; i < runtime_var_count; i++) {
        if (runtime_vars[i].is_used) {
            if (runtime_vars[i].type == RT_VAR_STRING && runtime_vars[i].value.string_value) {
                mod_free(runtime_vars[i].value.string_value);
                runtime_vars[i].value.string_value = NULL;
            } else if (runtime_vars[i].type == RT_VAR_HANDLE && runtime_vars[i].value.handle_ptr) {
                release_obj(runtime_vars[i].value.handle_ptr);
                runtime_vars[i].value.handle_ptr = NULL;
            }
        }
        runtime_vars[i].is_used = 0;
    }
    runtime_var_count = 0;
    
    // Clean up stack
    while (stack_top >= 0) {
        stack_value_t val = pop_value();
        free_value_shallow(val);
    }

    // Stable registry drain: pop-last strategy avoids index invalidation.
    if (object_count > 0) {
        runtime_dump_registry("pre-drain");
        int stall_passes = 0;
        while (object_count > 0) {
            int before = object_count;
            void *obj = object_registry[object_count - 1];
            release_obj(obj);
            if (object_count == before) {
                // Stalled: cycle or sentinel interference. Break cycle.
                stall_passes++;
                if (stall_passes > 4) {
                    // Force collapse of all remaining objects.
                    for (int i = 0; i < object_count; i++) {
                        rt_object_header_t *h = (rt_object_header_t *)object_registry[i];
                        h->freeing = 0; // allow re-entry
                        if (h->refcount < 1) h->refcount = 1;
                        if (h->refcount > 1) h->refcount = 1; // normalize
                    }
                    runtime_dump_registry("forced-collapse");
                } else {
                    for (int i = 0; i < object_count; i++) {
                        rt_object_header_t *h = (rt_object_header_t *)object_registry[i];
                        if (h->freeing) h->freeing = 0; // reset partial free state
                    }
                }
                if (stall_passes > 8) {
                    runtime_dump_registry("leak-abort");
                    printf("Runtime warning: leaked %d object(s); aborting cleanup to prevent hang\n", object_count);
                    break;
                }
            } else {
                stall_passes = 0; // progress made
            }
        }
        runtime_dump_registry("post-drain");
    }
}

/*
 * Bytecode runtime/interpreter
 */
int run_bytecode_file(const char *bytecode_file)
{
    printf("Running bytecode file '%s'...\n", bytecode_file);
    
    // Open bytecode file
    FILE *file = fopen(bytecode_file, "rb");
    if (!file) {
        printf("Error: Cannot open bytecode file '%s'\n", bytecode_file);
        return 1;
    }
    
    // Read header
    oakscode_header_t header;
    if (fread(&header, sizeof(header), 1, file) != 1) {
        printf("Error: Failed to read bytecode header\n");
        fclose(file);
        return 2;
    }
    
    // Verify magic
    if (mod_strncmp(header.magic, "OAKSCODE", 8) != 0) {
        printf("Error: Invalid bytecode file format\n");
        fclose(file);
        return 3;
    }
    
    printf("Bytecode version: %u, code: %u bytes, data: %u bytes\n", 
           header.version, header.code_size, header.data_size);
    
    // Read bytecode using module-safe memory
    unsigned char *code = (unsigned char*)mod_malloc(header.code_size);
    if (!code || fread(code, 1, header.code_size, file) != header.code_size) {
        printf("Error: Failed to read bytecode\n");
        fclose(file);
        if (code) mod_free(code);
        return 4;
    }
    
    // Read data section using module-safe memory
    char *data = NULL;
    if (header.data_size > 0) {
        data = (char*)mod_malloc(header.data_size);
        if (!data || fread(data, 1, header.data_size, file) != header.data_size) {
            printf("Error: Failed to read data section\n");
            fclose(file);
            mod_free(code);
            if (data) mod_free(data);
            return 5;
        }
    }
    
    fclose(file);

     /* Load optional .dbg line map sidecar (v1: off line snippet) (v2: off line col end_col snippet)
         Backwards compatibility: we auto-detect version by counting tab separators per line. */
    /* Reset debug map globals for this run */
    g_dbg_count = 0; g_dbg_cap = 0; if(g_dbg_map){ mod_free(g_dbg_map); g_dbg_map=NULL; }
    char dbg_name[260];
    int blen = (int)mod_strlen(bytecode_file); if (blen > 240) blen = 240;
    mod_strncpy(dbg_name, bytecode_file, blen); dbg_name[blen]='\0'; mod_strcat(dbg_name, ".dbg");
    FILE *dbg = fopen(dbg_name, "r");
    if (dbg) {
        char linebuf[256];
        while (fgets(linebuf, sizeof(linebuf), dbg)) {
            if (linebuf[0]=='#' || linebuf[0]=='\n' || linebuf[0]=='\0') continue;
            /* Count tabs to distinguish versions */
            int tabc = 0; for(char *p=linebuf; *p; p++){ if(*p=='\t') tabc++; }
            int off=0, ln=0, col=1, end_col=1; char snip[128]; snip[0]='\0';
            if (tabc >= 4) {
                /* v2: off line col end_col snippet */
                char *t1 = mod_strchr(linebuf,'\t'); if(!t1) continue; *t1='\0'; off = mod_atoi(linebuf);
                char *t2 = mod_strchr(t1+1,'\t'); if(!t2) continue; *t2='\0'; ln = mod_atoi(t1+1);
                char *t3 = mod_strchr(t2+1,'\t'); if(!t3) continue; *t3='\0'; col = mod_atoi(t2+1);
                char *t4 = mod_strchr(t3+1,'\t'); if(!t4) continue; *t4='\0'; end_col = mod_atoi(t3+1);
                char *sn = t4+1; int ll=(int)mod_strlen(sn); if(ll>0 && (sn[ll-1]=='\n'||sn[ll-1]=='\r')) sn[ll-1]='\0'; mod_strncpy(snip, sn, sizeof(snip)-1); snip[sizeof(snip)-1]='\0';
            } else {
                /* v1 fallback: off line snippet */
                char *tab1 = mod_strchr(linebuf,'\t'); if(!tab1) continue; char *tab2 = mod_strchr(tab1+1,'\t');
                if (!tab2) continue; *tab1='\0'; *tab2='\0'; off = mod_atoi(linebuf); ln = mod_atoi(tab1+1); mod_strncpy(snip, tab2+1, sizeof(snip)-1); snip[sizeof(snip)-1]='\0';
                int sl = (int)mod_strlen(snip); if (sl>0 && (snip[sl-1]=='\n' || snip[sl-1]=='\r')) snip[sl-1]='\0';
                col = 1; end_col = col + (int)mod_strlen(snip) - 1; if (end_col < col) end_col = col;
            }
            if (g_dbg_count+1 > g_dbg_cap) { int nc = g_dbg_cap? g_dbg_cap*2:128; dbg_line_entry_t *tmp=(dbg_line_entry_t*)mod_realloc(g_dbg_map, nc * sizeof(dbg_line_entry_t)); if(tmp){ g_dbg_map=tmp; g_dbg_cap=nc; } else break; }
            if (g_dbg_count < g_dbg_cap) { g_dbg_map[g_dbg_count].offset=off; g_dbg_map[g_dbg_count].line=ln; g_dbg_map[g_dbg_count].col=col; g_dbg_map[g_dbg_count].end_col=end_col; mod_strncpy(g_dbg_map[g_dbg_count].snippet, snip, sizeof(g_dbg_map[g_dbg_count].snippet)-1); g_dbg_map[g_dbg_count].snippet[sizeof(g_dbg_map[g_dbg_count].snippet)-1]='\0'; g_dbg_count++; }
        }
        fclose(dbg);
        if (g_dbg_count>0) printf("Loaded debug map (%d entries)\n", g_dbg_count);
    }

    /* Load optional .sym function symbol table sidecar */
    /* Reset symbol table globals for this run */
    g_sym_count = 0; g_sym_cap = 0; if(g_sym_funcs){ mod_free(g_sym_funcs); g_sym_funcs=NULL; }
    char sym_name[260];
    mod_strncpy(sym_name, bytecode_file, blen); sym_name[blen]='\0'; mod_strcat(sym_name, ".sym");
    FILE *sym = fopen(sym_name, "r");
    if (sym) {
        char linebuf[256];
        while (fgets(linebuf, sizeof(linebuf), sym)) {
            if (linebuf[0]=='#' || linebuf[0]=='\n' || linebuf[0]=='\0') continue;
            int st=0,en=0,pcnt=0; char fname[64]; char plist[128]; fname[0]='\0'; plist[0]='\0';
            /* Format: start\tend\tparams\tname\tparam_list */
            char *t1 = mod_strchr(linebuf,'\t'); if(!t1) continue; *t1='\0'; st = mod_atoi(linebuf);
            char *t2 = mod_strchr(t1+1,'\t'); if(!t2) continue; *t2='\0'; en = mod_atoi(t1+1);
            char *t3 = mod_strchr(t2+1,'\t'); if(!t3) continue; *t3='\0'; pcnt = mod_atoi(t2+1);
            char *t4 = mod_strchr(t3+1,'\t'); if(!t4) continue; *t4='\0'; mod_strncpy(fname, t3+1, sizeof(fname)-1); fname[sizeof(fname)-1]='\0';
            char *plist_src = t4+1; int ll = (int)mod_strlen(plist_src); if(ll>0 && (plist_src[ll-1]=='\n'||plist_src[ll-1]=='\r')) plist_src[ll-1]='\0';
            mod_strncpy(plist, plist_src, sizeof(plist)-1); plist[sizeof(plist)-1]='\0';
            if (g_sym_count+1 > g_sym_cap) { int nc = g_sym_cap? g_sym_cap*2:64; sym_func_entry_t *tmp=(sym_func_entry_t*)mod_realloc(g_sym_funcs, nc*sizeof(sym_func_entry_t)); if(tmp){ g_sym_funcs=tmp; g_sym_cap=nc; } else break; }
            if (g_sym_count < g_sym_cap) { g_sym_funcs[g_sym_count].start=st; g_sym_funcs[g_sym_count].end=en; g_sym_funcs[g_sym_count].params=pcnt; mod_strncpy(g_sym_funcs[g_sym_count].name,fname,sizeof(g_sym_funcs[g_sym_count].name)-1); g_sym_funcs[g_sym_count].name[sizeof(g_sym_funcs[g_sym_count].name)-1]='\0'; mod_strncpy(g_sym_funcs[g_sym_count].param_list, plist, sizeof(g_sym_funcs[g_sym_count].param_list)-1); g_sym_funcs[g_sym_count].param_list[sizeof(g_sym_funcs[g_sym_count].param_list)-1]='\0'; g_sym_count++; }
        }
        fclose(sym);
        if (g_sym_count>0) printf("Loaded symbol table (%d functions)\n", g_sym_count);
    }
    /* Helpers now at file scope above */
    
    // Initialize runtime state
    runtime_var_count = 0;
    stack_top = -1;
    call_top = -1;
    try_top = -1;
    
    // NOTE: Do not register interpreter built-ins as runtime objects here.
    // We keep a single source of truth for built-ins in the interpreter.
    // The runtime will directly handle only a minimal set of VM-native helpers
    // (e.g. regex primitives) inside OP_CALL_BUILTIN. All other names should
    // be delegated by a shared bridge (to be wired) rather than duplicated.
    
    // Initialize common variables that the bytecode might expect
    stack_value_t int_val;
    int_val.type = RT_VAR_INT;
    int_val.value.int_value = 0;
    store_variable("i", int_val);
    store_variable("j", int_val);
    store_variable("k", int_val);
    // Common loop indices used by examples/tests
    store_variable("idx", int_val);
    store_variable("index", int_val);
    store_variable("count", int_val);
    
    // Initialize features variable that was missing
    stack_value_t features_val;
    features_val.type = RT_VAR_STRING;
    features_val.value.string_value = mod_strdup("default_features");
    store_variable("features", features_val);
    
    // Execute bytecode
    int pc = 0;  // Program counter
    
    while (pc < (int)header.code_size) {
        opcode_t op = (opcode_t)code[pc++];
        
        switch (op) {
            case OP_NOP:
                break;
                
            case OP_LOAD_INT: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated LOAD_INT instruction\n");
                    goto cleanup;
                }
                int value;
                mod_memcpy(&value, code + pc, 4);
                pc += 4;
                push_int(value);
                break;
            }
            
            case OP_LOAD_FLOAT: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated LOAD_FLOAT instruction\n");
                    goto cleanup;
                }
                float fvalue = 0.0f;
                mod_memcpy(&fvalue, code + pc, 4);
                pc += 4;
                push_float(fvalue);
                break;
            }
                
            case OP_LOAD_STRING: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated LOAD_STRING instruction\n");
                    goto cleanup;
                }
                int offset;
                mod_memcpy(&offset, code + pc, 4);
                pc += 4;
                
                // Load string from data section with extra validation
                if (data && offset >= 0 && offset < (int)header.data_size) {
                    // Check that the string is null-terminated within bounds
                    const char *str = data + offset;
                    int max_len = (int)header.data_size - offset;
                    int str_len = 0;
                    while (str_len < max_len && str[str_len] != '\0') {
                        str_len++;
                    }
                    if (str_len < max_len) {
                        push_string(str);
                    } else {
                        printf("Runtime error: Unterminated string at offset %d\n", offset);
                        goto cleanup;
                    }
                } else {
                    printf("Runtime error: Invalid string offset %d\n", offset);
                    goto cleanup;
                }
                break;
            }
            
            case OP_LOAD_VAR: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated LOAD_VAR instruction\n");
                    goto cleanup;
                }
                int offset;
                mod_memcpy(&offset, code + pc, 4);
                pc += 4;
                
                if (data && offset >= 0 && offset < (int)header.data_size) {
                    // Validate variable name string
                    const char *var_name = data + offset;
                    int max_len = (int)header.data_size - offset;
                    int name_len = 0;
                    while (name_len < max_len && var_name[name_len] != '\0') {
                        name_len++;
                    }
                    if (name_len < max_len) {
                        load_variable(var_name);
                    } else {
                        printf("Runtime error: Unterminated variable name at offset %d\n", offset);
                        goto cleanup;
                    }
                } else {
                    printf("Runtime error: Invalid variable name offset %d\n", offset);
                    goto cleanup;
                }
                break;
            }
            
            case OP_STORE_VAR: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated STORE_VAR instruction\n");
                    goto cleanup;
                }
                int offset;
                mod_memcpy(&offset, code + pc, 4);
                pc += 4;
                
                if (stack_top < 0) {
                    printf("Runtime error: No value on stack for STORE_VAR at pc=%d\n", pc-5);
                    printf("Runtime error: This suggests a previous operation failed to push a value\n");
                    goto cleanup;
                }
                
                if (data && offset >= 0 && offset < (int)header.data_size) {
                    // Validate variable name string
                    const char *var_name = data + offset;
                    int max_len = (int)header.data_size - offset;
                    int name_len = 0;
                    while (name_len < max_len && var_name[name_len] != '\0') {
                        name_len++;
                    }
                    if (name_len < max_len) {
                        stack_value_t value = pop_value();
                        store_variable(var_name, value);
                    } else {
                        printf("Runtime error: Unterminated variable name at offset %d\n", offset);
                        goto cleanup;
                    }
                } else {
                    printf("Runtime error: Invalid variable name offset %d\n", offset);
                    goto cleanup;
                }
                break;
            }
            
            case OP_PRINT_INT: {
                if (stack_top < 0) {
                    printf("Runtime error: No value on stack for PRINT_INT\n");
                    goto cleanup;
                }
                stack_value_t value = pop_value();
                if (value.type == RT_VAR_INT) {
                    printf("%d\n", value.value.int_value);
                } else {
                    printf("Runtime error: Expected integer for PRINT_INT\n");
                    if (value.type == RT_VAR_STRING && value.value.string_value) {
                        mod_free(value.value.string_value);
                    }
                    goto cleanup;
                }
                break;
            }
            
            case OP_PRINT_STRING: {
                if (stack_top < 0) {
                    printf("Runtime error: No value on stack for PRINT_STRING\n");
                    goto cleanup;
                }
                stack_value_t value = pop_value();
                if (value.type == RT_VAR_STRING) {
                    printf("%s\n", value.value.string_value);
                    mod_free(value.value.string_value);
                } else {
                    printf("Runtime error: Expected string for PRINT_STRING\n");
                    goto cleanup;
                }
                break;
            }
            

            
            case OP_ADD: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for ADD\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value + b.value.int_value);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_float(av + bv);
                } else {
                    printf("Runtime error: ADD requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_SUB: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for SUB\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value - b.value.int_value);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_float(av - bv);
                } else {
                    printf("Runtime error: SUB requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_MUL: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for MUL\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value * b.value.int_value);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_float(av * bv);
                } else {
                    printf("Runtime error: MUL requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_DIV: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for DIV\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    if (b.value.int_value == 0) {
                        printf("Runtime error: Division by zero\n");
                        goto cleanup;
                    }
                    push_int(a.value.int_value / b.value.int_value);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    if (fabsf(bv) < 1e-38f) { printf("Runtime error: Division by zero\n"); goto cleanup; }
                    push_float(av / bv);
                } else {
                    printf("Runtime error: DIV requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }

            case OP_CMP_EQ: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value == b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(fabsf(av - bv) < 1e-6f ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_CMP_NE: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value != b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(fabsf(av - bv) >= 1e-6f ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_CMP_LT: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value < b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(av < bv ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_CMP_LE: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value <= b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(av <= bv ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_CMP_GT: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value > b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(av > bv ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_CMP_GE: {
                if (stack_top < 1) {
                    printf("Runtime error: Not enough values on stack for comparison\n");
                    goto cleanup;
                }
                stack_value_t b = pop_value();
                stack_value_t a = pop_value();
                
                if (a.type == RT_VAR_INT && b.type == RT_VAR_INT) {
                    push_int(a.value.int_value >= b.value.int_value ? 1 : 0);
                } else if ((a.type == RT_VAR_INT || a.type == RT_VAR_FLOAT) && (b.type == RT_VAR_INT || b.type == RT_VAR_FLOAT)) {
                    float av = (a.type == RT_VAR_FLOAT) ? a.value.float_value : (float)a.value.int_value;
                    float bv = (b.type == RT_VAR_FLOAT) ? b.value.float_value : (float)b.value.int_value;
                    push_int(av >= bv ? 1 : 0);
                } else {
                    printf("Runtime error: Comparison requires numeric types\n");
                    if (a.type == RT_VAR_STRING && a.value.string_value) mod_free(a.value.string_value);
                    if (b.type == RT_VAR_STRING && b.value.string_value) mod_free(b.value.string_value);
                    goto cleanup;
                }
                break;
            }
            
            case OP_JUMP: {
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated JUMP instruction\n");
                    goto cleanup;
                }
                int jump_addr;
                mod_memcpy(&jump_addr, code + pc, 4);
                if (!is_valid_pc(jump_addr, header.code_size)) {
                    printf("Runtime error: Invalid JUMP target %d (code size %u)\n", jump_addr, header.code_size);
                    goto cleanup;
                }
                pc = jump_addr;
                break;
            }
            
            case OP_JUMP_IF_FALSE:
            case OP_JUMP_FALSE: { // Alias for OP_JUMP_IF_FALSE
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated JUMP_IF_FALSE instruction\n");
                    goto cleanup;
                }
                int jump_addr;
                mod_memcpy(&jump_addr, code + pc, 4);
                pc += 4;
                if (!is_valid_pc(jump_addr, header.code_size)) {
                    printf("Runtime error: Invalid conditional JUMP target %d (code size %u)\n", jump_addr, header.code_size);
                    goto cleanup;
                }
                
                if (stack_top < 0) {
                    printf("Runtime error: No value on stack for conditional jump\n");
                    goto cleanup;
                }
                
                stack_value_t condition = pop_value();
                if (condition.type == RT_VAR_INT) {
                    if (condition.value.int_value == 0) {
                        pc = jump_addr; // Jump if false (zero)
                    }
                } else if (condition.type == RT_VAR_FLOAT) {
                    if (fabsf(condition.value.float_value) < 1e-38f) pc = jump_addr;
                } else {
                    printf("Runtime error: Conditional jump requires numeric condition\n");
                    if (condition.type == RT_VAR_STRING && condition.value.string_value) {
                        mod_free(condition.value.string_value);
                    }
                    goto cleanup;
                }
                break;
            }

            case OP_TRY: {
                // Format: [handler_pc:int]
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated TRY instruction\n");
                    goto cleanup;
                }
                int handler_pc = 0;
                mod_memcpy(&handler_pc, code + pc, 4);
                pc += 4;
                if (!is_valid_pc(handler_pc, header.code_size)) {
                    printf("Runtime error: Invalid TRY handler target %d (code size %u)\n", handler_pc, header.code_size);
                    goto cleanup;
                }
                if (try_top >= MAX_TRY_DEPTH - 1) {
                    printf("Runtime error: Try stack overflow\n");
                    goto cleanup;
                }
                try_top++;
                try_stack[try_top].handler_pc = handler_pc;
                try_stack[try_top].call_top_at_try = call_top;
                try_stack[try_top].stack_top_at_try = stack_top;
                break;
            }

            case OP_END_TRY: {
                if (try_top < 0) {
                    printf("Runtime error: END_TRY with empty try stack\n");
                    goto cleanup;
                }
                try_top--;
                break;
            }

            case OP_THROW: {
                // Pop exception value (int or string), then unwind to nearest handler
                stack_value_t exc;
                if (stack_top >= 0) exc = pop_value();
                else { exc.type = RT_VAR_INT; exc.value.int_value = 1; }

                if (try_top < 0) {
                    // Uncaught exception
                    if (exc.type == RT_VAR_STRING && exc.value.string_value) {
                        printf("Uncaught exception: %s\n", exc.value.string_value);
                        mod_free(exc.value.string_value);
                    } else if (exc.type == RT_VAR_INT) {
                        printf("Uncaught exception: %d\n", exc.value.int_value);
                    } else {
                        printf("Uncaught exception\n");
                    }
                    goto cleanup;
                }

                // Get nearest handler
                try_entry_t handler = try_stack[try_top];
                // Pop handler (we're transferring control to catch)
                try_top--;

                // Unwind call frames until we reach the frame depth at time of try
                while (call_top > handler.call_top_at_try) {
                    // Clean locals
                    for (int i = 0; i < call_stack[call_top].local_count; i++) {
                        if (call_stack[call_top].locals[i].is_used) {
                            if (call_stack[call_top].locals[i].type == RT_VAR_STRING && call_stack[call_top].locals[i].value.string_value) {
                                mod_free(call_stack[call_top].locals[i].value.string_value);
                            } else if (call_stack[call_top].locals[i].type == RT_VAR_HANDLE && call_stack[call_top].locals[i].value.handle_ptr) {
                                release_obj(call_stack[call_top].locals[i].value.handle_ptr);
                            }
                        }
                        call_stack[call_top].locals[i].is_used = 0;
                    }
                    call_stack[call_top].local_count = 0;
                    // Drop stack to marker
                    int marker = call_stack[call_top].stack_marker;
                    while (stack_top >= marker) {
                        stack_value_t v = pop_value();
                        free_value_shallow(v);
                    }
                    call_top--;
                }

                // Restore stack to the depth at time of try
                while (stack_top > handler.stack_top_at_try) {
                    stack_value_t v = pop_value();
                    free_value_shallow(v);
                }

                // Push exception value for catch block
                if (exc.type == RT_VAR_INT) {
                    push_int(exc.value.int_value);
                } else if (exc.type == RT_VAR_STRING) {
                    push_string(exc.value.string_value);
                    if (exc.value.string_value) mod_free(exc.value.string_value);
                }

                // Jump to handler PC
                pc = handler.handler_pc;
                break;
            }

            case OP_PRINT: {
                // Handle both int and string printing
                if (stack_top < 0) {
                    printf("Runtime error: No value on stack for PRINT\n");
                    goto cleanup;
                }
                stack_value_t value = pop_value();
                if (value.type == RT_VAR_INT) {
                    printf("%d\n", value.value.int_value);
                } else if (value.type == RT_VAR_FLOAT) {
                    printf("%g\n", (double)value.value.float_value);
                } else if (value.type == RT_VAR_STRING) {
                    printf("%s\n", value.value.string_value);
                    mod_free(value.value.string_value);
                } else if (value.type == RT_VAR_HANDLE) {
                    printf("[object]\n");
                }
                break;
            }
            
            case OP_CALL: {
                // Generic function call - expects function object on stack
                // Format: [argc:int]
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated CALL instruction\n");
                    goto cleanup;
                }
                int argc = 0;
                mod_memcpy(&argc, code + pc, 4);
                pc += 4;
                
                if (stack_top < argc) {
                    printf("Runtime error: Not enough arguments on stack for CALL\n");
                    goto cleanup;
                }
                
                // Pop the function object (last on stack after args)
                stack_value_t func_obj = pop_value();
                if (func_obj.type != RT_VAR_HANDLE || !func_obj.value.handle_ptr) {
                    printf("Runtime error: CALL requires function object\n");
                    goto cleanup;
                }
                
                // For now, treat all function objects as built-in function stubs
                // In the future, this could handle different function types
                rt_object_header_t *obj = (rt_object_header_t *)func_obj.value.handle_ptr;
                if (obj->type == OBJ_DICT) { // Built-in function placeholder
                    // Pop args but don't use them for stubs - just push a default result
                    for (int i = 0; i < argc; i++) {
                        stack_value_t arg = pop_value();
                        if (arg.type == RT_VAR_STRING && arg.value.string_value) {
                            mod_free(arg.value.string_value);
                        }
                    }
                    push_null(); // Default return value
                } else {
                    printf("Runtime error: Invalid function object type\n");
                    goto cleanup;
                }
                break;
            }
            
            case OP_CALL_BUILTIN: {
                // Format: [name_offset:int][argc:int]
                if (pc + 8 > (int)header.code_size) {
                    printf("Runtime error: Truncated CALL_BUILTIN instruction\n");
                    goto cleanup;
                }
                int name_off = 0; int argc = 0;
                mod_memcpy(&name_off, code + pc, 4);
                mod_memcpy(&argc, code + pc + 4, 4);
                pc += 8;

                if (!is_valid_cstring(data, (int)header.data_size, name_off)) {
                    printf("Runtime error: Invalid or unterminated name in CALL_BUILTIN (off=%d)\n", name_off);
                    goto cleanup;
                }
                char *func_name = (char *)(data + name_off);

                // Pop args into an array in call order (args[0] is first argument)
                #define BUILTIN_MAX_ARGS 16
                if (argc < 0 || argc > BUILTIN_MAX_ARGS) argc = (argc < 0) ? 0 : BUILTIN_MAX_ARGS;
                stack_value_t args[BUILTIN_MAX_ARGS];
                for (int i = 0; i < argc; i++) {
                    // Stack is LIFO: last pushed is last arg
                    args[argc - 1 - i] = pop_value();
                }
                int after_pop_top = stack_top;
                #define FREE_ARGS() do { \
                    for (int ai = 0; ai < argc; ai++) { \
                        if (args[ai].type == RT_VAR_STRING && args[ai].value.string_value) { \
                            mod_free(args[ai].value.string_value); \
                        } \
                    } \
                    if (stack_top <= after_pop_top) { \
                        push_null(); \
                    } \
                } while (0)

                int used_bridge = 0;
                if (argc >= 0) {
                    // Attempt bridge dispatch first for full interpreter parity.
                    bridge_value_t bargs[BUILTIN_MAX_ARGS];
                    bridge_value_t bout; bridge_value_init(&bout);
                    if (argc > BUILTIN_MAX_ARGS) argc = BUILTIN_MAX_ARGS; // clamp
                    for (int i = 0; i < argc; i++) bridge_value_init(&bargs[i]);
                    // Convert runtime args -> bridge args
                    for (int i = 0; i < argc; i++) {
                        stack_value_t *sv = &args[i];
                        if (sv->type == RT_VAR_INT) { bargs[i].type = BRIDGE_VAL_INT; bargs[i].data.i = sv->value.int_value; }
                        else if (sv->type == RT_VAR_FLOAT) { bargs[i].type = BRIDGE_VAL_FLOAT; bargs[i].data.f = sv->value.float_value; }
                        else if (sv->type == RT_VAR_STRING) { bargs[i].type = BRIDGE_VAL_STRING; bargs[i].data.s = sv->value.string_value; bargs[i].owns = 0; }
                        else if (sv->type == RT_VAR_HANDLE) { bargs[i].type = BRIDGE_VAL_HANDLE; bargs[i].data.handle = sv->value.handle_ptr; }
                        else { bargs[i].type = BRIDGE_VAL_NULL; }
                    }
                    int bd = bridge_dispatch(func_name, argc, bargs, &bout);
                    if (bd == BRIDGE_OK) {
                        // Free original string args we consumed if any
                        for (int i = 0; i < argc; i++) {
                            if (args[i].type == RT_VAR_STRING && args[i].value.string_value) {
                                mod_free(args[i].value.string_value);
                                args[i].value.string_value = NULL;
                            }
                        }
                        // Push bridge result
                        switch (bout.type) {
                            case BRIDGE_VAL_INT: push_int(bout.data.i); break;
                            case BRIDGE_VAL_FLOAT: push_float(bout.data.f); break;
                            case BRIDGE_VAL_STRING: push_string(bout.data.s ? bout.data.s : ""); if (bout.owns && bout.data.s) mod_free(bout.data.s); break;
                            case BRIDGE_VAL_HANDLE: push_handle(bout.data.handle); break;
                            case BRIDGE_VAL_NULL: default: push_null(); break;
                        }
                        bridge_value_free(&bout);
                        used_bridge = 1;
                    } else if (bd == BRIDGE_ERROR) {
                                /* Bridge failure parity: create BuiltinError. */
                                char msg[128]; mod_snprintf(msg,sizeof(msg),"Builtin %s failed", func_name?func_name:"?");
                                void *exc = rt_exception_create("BuiltinError", msg, bytecode_file, 0);
                        if (exc) {
                            /* Attempt a debug line lookup using next instruction pointer (pc still points after call header). */
                            int approx_line = 0, approx_col = 0, approx_end = 0; if (g_dbg_count>0) { dbg_lookup_line_cols(pc, &approx_line, &approx_col, &approx_end); }
                            const char *fname = func_name?func_name:"<builtin>";
                            if (approx_col>0) rt_exception_add_frame_col(exc, fname, bytecode_file, approx_line, approx_col, approx_end);
                            else rt_exception_add_frame(exc, fname, bytecode_file, approx_line);
                            push_handle(exc);
                        } else {
                            push_null();
                        }
                        bridge_value_free(&bout);
                        FREE_ARGS();
                        break; /* Continue execution */
                    }
                }
                if (used_bridge) { FREE_ARGS(); break; }

                // All known built-ins are now handled exclusively via bridge_dispatch above.
                // If we reached here, the bridge did not recognize the function name.
                printf("Runtime warning: Unknown built-in '%s' - returning null (bridge fallback)\n", func_name);
                push_null();
                FREE_ARGS();
                break;
            }
            
            case OP_CALL_USER: {
                // Format: [addr:int][argc:int] with args already pushed (left-to-right)
                if (pc + 8 > (int)header.code_size) {
                    printf("Runtime error: Truncated CALL_USER instruction\n");
                    goto cleanup;
                }
                int target_addr = 0;
                int argc = 0;
                mod_memcpy(&target_addr, code + pc, 4);
                mod_memcpy(&argc, code + pc + 4, 4);
                pc += 8;
                if (!is_valid_pc(target_addr, header.code_size)) {
                    printf("Runtime error: Invalid CALL_USER target %d (code size %u)\n", target_addr, header.code_size);
                    goto cleanup;
                }
                if (argc < 0) argc = 0;

                if (call_top >= MAX_CALL_DEPTH - 1) {
                    printf("Runtime error: Call stack overflow\n");
                    goto cleanup;
                }
                call_top++;
                call_stack[call_top].return_pc = pc;
                call_stack[call_top].stack_marker = stack_top - argc + 1; // position of first arg on stack
                call_stack[call_top].local_count = 0;
                // Jump to function body
                pc = target_addr;
                /* Automatic frame injection: append frame for active exception (deferred stack building).
                   If no current exception, we defer until an exception arises (future improvement: maintain shadow call trace). */
                void *cur_exc = rt_exception_current();
                if (cur_exc) {
                    int line_no = dbg_lookup_line(target_addr); int col_no=0, end_col=0; if(g_dbg_count>0){ dbg_lookup_line_cols(target_addr,&line_no,&col_no,&end_col); }
                    const char *sname = sym_lookup(target_addr);
                    char fname[64];
                    if (sname) { mod_strncpy(fname, sname, sizeof(fname)-1); fname[sizeof(fname)-1]='\0'; }
                    else { mod_snprintf(fname,sizeof(fname),"<fn@%d>", target_addr); }
                    if(col_no>0) rt_exception_add_frame_col(cur_exc, fname, bytecode_file, line_no, col_no, end_col); else rt_exception_add_frame(cur_exc, fname, bytecode_file, line_no);
                }
                break;
            }
            
            case OP_RETURN: {
                if (call_top < 0) {
                    printf("Runtime error: RETURN with empty call stack\n");
                    goto cleanup;
                }
                // Return value is on stack top
                if (stack_top < 0) {
                    printf("Runtime error: RETURN without value on stack\n");
                    goto cleanup;
                }
                stack_value_t ret = pop_value();

                // Drop any leftover stack entries back to stack_marker
                int marker = call_stack[call_top].stack_marker;
                while (stack_top >= marker) {
                    stack_value_t v = pop_value();
                    free_value(&v);
                }

                // Push return value
                if (ret.type == RT_VAR_INT) {
                    push_int(ret.value.int_value);
                } else if (ret.type == RT_VAR_FLOAT) {
                    push_float(ret.value.float_value);
                } else if (ret.type == RT_VAR_STRING) {
                    push_string(ret.value.string_value);
                    if (ret.value.string_value) mod_free(ret.value.string_value);
                } else if (ret.type == RT_VAR_HANDLE) {
                    push_handle(ret.value.handle_ptr);
                } else if (ret.type == RT_VAR_NULL) {
                    push_null();
                }

                // Restore PC
                pc = call_stack[call_top].return_pc;
                // Free any string/handle locals
                for (int i = 0; i < call_stack[call_top].local_count; i++) {
                    if (call_stack[call_top].locals[i].is_used) {
                        if (call_stack[call_top].locals[i].type == RT_VAR_STRING && call_stack[call_top].locals[i].value.string_value) {
                            mod_free(call_stack[call_top].locals[i].value.string_value);
                            call_stack[call_top].locals[i].value.string_value = NULL;
                        } else if (call_stack[call_top].locals[i].type == RT_VAR_HANDLE && call_stack[call_top].locals[i].value.handle_ptr) {
                            release_obj(call_stack[call_top].locals[i].value.handle_ptr);
                            call_stack[call_top].locals[i].value.handle_ptr = NULL;
                        }
                    }
                    call_stack[call_top].locals[i].is_used = 0;
                }
                call_stack[call_top].local_count = 0;
                // Remove any try frames associated with this call frame
                int cur_frame = call_top;
                while (try_top >= 0 && try_stack[try_top].call_top_at_try == cur_frame) {
                    try_top--;
                }
                call_top--;
                break;
            }
            
            case OP_LOOP_START: {
                // Mark the start of a loop - no-op for now, could be used for debugging
                break;
            }
            
            case OP_LOOP_END: {
                // Mark the end of a loop - no-op for now, could be used for debugging  
                break;
            }
            
            case OP_LAMBDA_CREATE: {
                // Create lambda function object
                // Format: [param_count:int] followed by lambda body (simplified for now)
                if (pc + 4 > (int)header.code_size) {
                    printf("Runtime error: Truncated LAMBDA_CREATE instruction\n");
                    goto cleanup;
                }
                
                int param_count = 0;
                mod_memcpy(&param_count, code + pc, 4);
                pc += 4;
                
                // Create a lambda object (simplified - just a placeholder handle)
                rt_object_header_t *lambda_obj = (rt_object_header_t *)mod_malloc(sizeof(rt_object_header_t) + sizeof(int));
                if (!lambda_obj) {
                    printf("Runtime error: Failed to allocate lambda object\n");
                    goto cleanup;
                }
                
                lambda_obj->refcount = 1;
                lambda_obj->type = OBJ_DICT; // Use DICT type as placeholder for lambda
                lambda_obj->freeing = 0;
                
                // Store parameter count after the header
                *((int*)(lambda_obj + 1)) = param_count;
                
                registry_add(lambda_obj);
                push_handle(lambda_obj);
                break;
            }
            
            case OP_LAMBDA_CALL: {
                // Call lambda function - for now just pop the lambda and arguments
                if (stack_top < 1) {
                    printf("Runtime error: No lambda on stack for LAMBDA_CALL\n");
                    goto cleanup;
                }
                
                stack_value_t lambda_val = pop_value();
                // For now, just push a null result
                push_null();
                
                // Clean up lambda reference
                free_value(&lambda_val);
                break;
            }
            
            case OP_DICT_CREATE: {
                // Create empty dictionary - push handle to stack
                rt_dict_t *d = (rt_dict_t *)mod_malloc(sizeof(rt_dict_t));
                if (!d) {
                    printf("Runtime error: Failed to allocate dictionary\n");
                    goto cleanup;
                }
                INIT_OBJ_HDR(d, OBJ_DICT);
                d->size = 0;
                d->cap = 8;
                d->items = (rt_kv_t *)mod_malloc(sizeof(rt_kv_t) * d->cap);
                if (!d->items) {
                    mod_free(d);
                    printf("Runtime error: Failed to allocate dictionary items\n");
                    goto cleanup;
                }
                registry_add(d);
                push_handle(d);
                break;
            }
            
            case OP_LIST_CREATE: {
                // Create empty list - push handle to stack
                rt_list_t *l = (rt_list_t *)mod_malloc(sizeof(rt_list_t));
                if (!l) {
                    printf("Runtime error: Failed to allocate list\n");
                    goto cleanup;
                }
                INIT_OBJ_HDR(l, OBJ_LIST);
                l->size = 0;
                l->cap = 8;
                l->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * l->cap);
                if (!l->items) {
                    mod_free(l);
                    printf("Runtime error: Failed to allocate list items\n");
                    goto cleanup;
                }
                registry_add(l);
                push_handle(l);
                break;
            }
            
            case OP_SET_CREATE: {
                // Create empty set - push handle to stack  
                rt_set_t *s = (rt_set_t *)mod_malloc(sizeof(rt_set_t));
                if (!s) {
                    printf("Runtime error: Failed to allocate set\n");
                    goto cleanup;
                }
                INIT_OBJ_HDR(s, OBJ_SET);
                s->size = 0;
                s->cap = 8;
                s->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * s->cap);
                if (!s->items) {
                    mod_free(s);
                    printf("Runtime error: Failed to allocate set items\n");
                    goto cleanup;
                }
                registry_add(s);
                push_handle(s);
                break;
            }
            
            case OP_MAP: {
                // Map operation: takes a list and a function, applies function to each element
                // Stack should have: [list] [lambda] (lambda on top)
                if (stack_top < 2) {
                    printf("Runtime error: MAP requires list and function on stack\n");
                    goto cleanup;
                }
                
                stack_value_t lambda_val = pop_value();
                stack_value_t list_val = pop_value();
                
                if (list_val.type != RT_VAR_HANDLE) {
                    printf("Runtime error: MAP first argument must be a list\n");
                    free_value(&lambda_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                rt_list_t *input_list = (rt_list_t *)list_val.value.handle_ptr;
                if (!input_list || input_list->hdr.type != OBJ_LIST) {
                    printf("Runtime error: MAP first argument must be a list\n");
                    free_value(&lambda_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Create result list
                rt_list_t *result_list = (rt_list_t *)mod_malloc(sizeof(rt_list_t));
                if (!result_list) {
                    printf("Runtime error: Failed to allocate result list for MAP\n");
                    free_value(&lambda_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                INIT_OBJ_HDR(result_list, OBJ_LIST);
                result_list->size = input_list->size;
                result_list->cap = input_list->size > 0 ? input_list->size : 1;
                result_list->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * result_list->cap);
                if (!result_list->items) {
                    mod_free(result_list);
                    printf("Runtime error: Failed to allocate result list items for MAP\n");
                    free_value(&lambda_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Apply function to each element (simplified - just copy for now)
                for (int i = 0; i < input_list->size; i++) {
                    // For now, just copy the element (placeholder implementation)
                    // TODO: Actually call the lambda function on each element
                    result_list->items[i] = copy_value(input_list->items[i]);
                }
                
                registry_add(result_list);
                push_handle(result_list);
                
                free_value(&lambda_val);
                free_value(&list_val);
                break;
            }
            
            case OP_FILTER: {
                // Filter operation: takes a list and a predicate function
                if (stack_top < 2) {
                    printf("Runtime error: FILTER requires list and predicate on stack\n");
                    goto cleanup;
                }
                
                stack_value_t predicate = pop_value();
                stack_value_t list_val = pop_value();
                
                if (list_val.type != RT_VAR_HANDLE) {
                    printf("Runtime error: FILTER first argument must be a list\n");
                    free_value(&predicate);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                rt_list_t *input_list = (rt_list_t *)list_val.value.handle_ptr;
                if (!input_list || input_list->hdr.type != OBJ_LIST) {
                    printf("Runtime error: FILTER first argument must be a list\n");
                    free_value(&predicate);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Create result list (simplified - for now just return original list)
                rt_list_t *result_list = (rt_list_t *)mod_malloc(sizeof(rt_list_t));
                if (!result_list) {
                    printf("Runtime error: Failed to allocate result list for FILTER\n");
                    free_value(&predicate);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                INIT_OBJ_HDR(result_list, OBJ_LIST);
                result_list->size = input_list->size;
                result_list->cap = input_list->size > 0 ? input_list->size : 1;
                result_list->items = (stack_value_t *)mod_malloc(sizeof(stack_value_t) * result_list->cap);
                if (!result_list->items) {
                    mod_free(result_list);
                    printf("Runtime error: Failed to allocate result list items for FILTER\n");
                    free_value(&predicate);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Copy all elements for now (TODO: apply predicate)
                for (int i = 0; i < input_list->size; i++) {
                    result_list->items[i] = copy_value(input_list->items[i]);
                }
                
                registry_add(result_list);
                push_handle(result_list);
                
                free_value(&predicate);
                free_value(&list_val);
                break;
            }
            
            case OP_REDUCE: {
                // Reduce operation: takes a list, initial value, and reducer function
                if (stack_top < 3) {
                    printf("Runtime error: REDUCE requires list, initial value, and function on stack\n");
                    goto cleanup;
                }
                
                stack_value_t reducer = pop_value();
                stack_value_t initial = pop_value();
                stack_value_t list_val = pop_value();
                
                // For now, just return the initial value (TODO: implement reduction)
                if (initial.type == RT_VAR_INT) push_int(initial.value.int_value);
                else if (initial.type == RT_VAR_FLOAT) push_float(initial.value.float_value);
                else if (initial.type == RT_VAR_STRING) push_string(initial.value.string_value);
                else if (initial.type == RT_VAR_HANDLE) push_handle(initial.value.handle_ptr);
                else push_null();
                
                free_value(&reducer);
                free_value(&initial);
                free_value(&list_val);
                break;
            }
            
            case OP_DICT_SET: {
                // Dictionary set: takes dict, key, value
                if (stack_top < 3) {
                    printf("Runtime error: DICT_SET requires dict, key, and value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                stack_value_t key_val = pop_value();
                stack_value_t dict_val = pop_value();
                
                if (dict_val.type != RT_VAR_HANDLE || key_val.type != RT_VAR_STRING) {
                    printf("Runtime error: DICT_SET requires dict and string key\n");
                    free_value(&value);
                    free_value(&key_val);
                    free_value(&dict_val);
                    goto cleanup;
                }
                
                rt_dict_t *dict = (rt_dict_t *)dict_val.value.handle_ptr;
                if (!dict || dict->hdr.type != OBJ_DICT) {
                    printf("Runtime error: DICT_SET first argument must be a dict\n");
                    free_value(&value);
                    free_value(&key_val);
                    free_value(&dict_val);
                    goto cleanup;
                }
                
                const char *key = key_val.value.string_value;
                
                // Find existing key or add new one
                int found = -1;
                for (int i = 0; i < dict->size; i++) {
                    if (mod_strcmp(dict->items[i].key, key) == 0) {
                        found = i;
                        break;
                    }
                }
                
                if (found >= 0) {
                    // Update existing key
                    free_value(&dict->items[found].value);
                    dict->items[found].value = copy_value(value);
                } else {
                    // Add new key-value pair
                    if (dict->size >= dict->cap) {
                        int new_cap = dict->cap * 2;
                        rt_kv_t *new_items = (rt_kv_t *)mod_realloc(dict->items, sizeof(rt_kv_t) * new_cap);
                        if (!new_items) {
                            printf("Runtime error: Failed to expand dict for DICT_SET\n");
                            free_value(&value);
                            free_value(&key_val);
                            free_value(&dict_val);
                            goto cleanup;
                        }
                        dict->items = new_items;
                        dict->cap = new_cap;
                    }
                    
                    dict->items[dict->size].key = mod_strdup(key);
                    dict->items[dict->size].value = copy_value(value);
                    dict->size++;
                }
                
                // Push dict back on stack
                push_handle(dict);
                retain_obj(dict);
                
                free_value(&value);
                free_value(&key_val);
                free_value(&dict_val);
                break;
            }
            
            case OP_DICT_GET: {
                // Dictionary get: takes dict and key, returns value
                if (stack_top < 2) {
                    printf("Runtime error: DICT_GET requires dict and key on stack\n");
                    goto cleanup;
                }
                
                stack_value_t key_val = pop_value();
                stack_value_t dict_val = pop_value();
                
                if (dict_val.type != RT_VAR_HANDLE || key_val.type != RT_VAR_STRING) {
                    printf("Runtime error: DICT_GET requires dict and string key\n");
                    free_value(&key_val);
                    free_value(&dict_val);
                    goto cleanup;
                }
                
                rt_dict_t *dict = (rt_dict_t *)dict_val.value.handle_ptr;
                if (!dict || dict->hdr.type != OBJ_DICT) {
                    printf("Runtime error: DICT_GET first argument must be a dict\n");
                    free_value(&key_val);
                    free_value(&dict_val);
                    goto cleanup;
                }
                
                const char *key = key_val.value.string_value;
                
                // Find the key
                int found = -1;
                for (int i = 0; i < dict->size; i++) {
                    if (mod_strcmp(dict->items[i].key, key) == 0) {
                        found = i;
                        break;
                    }
                }
                
                if (found >= 0) {
                    stack_value_t element = copy_value(dict->items[found].value);
                    if (element.type == RT_VAR_INT) push_int(element.value.int_value);
                    else if (element.type == RT_VAR_FLOAT) push_float(element.value.float_value);
                    else if (element.type == RT_VAR_STRING) push_string(element.value.string_value);
                    else if (element.type == RT_VAR_HANDLE) push_handle(element.value.handle_ptr);
                    else push_null();
                } else {
                    push_null();
                }
                
                free_value(&key_val);
                free_value(&dict_val);
                break;
            }
                
            case OP_LIST_APPEND: {
                // List append: takes a list and a value, appends value to list
                if (stack_top < 2) {
                    printf("Runtime error: LIST_APPEND requires list and value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                stack_value_t list_val = pop_value();
                
                if (list_val.type != RT_VAR_HANDLE) {
                    printf("Runtime error: LIST_APPEND first argument must be a list\n");
                    free_value(&value);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                rt_list_t *list = (rt_list_t *)list_val.value.handle_ptr;
                if (!list || list->hdr.type != OBJ_LIST) {
                    printf("Runtime error: LIST_APPEND first argument must be a list\n");
                    free_value(&value);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Expand list if needed
                if (list->size >= list->cap) {
                    int new_cap = list->cap * 2;
                    stack_value_t *new_items = (stack_value_t *)mod_realloc(list->items, sizeof(stack_value_t) * new_cap);
                    if (!new_items) {
                        printf("Runtime error: Failed to expand list for LIST_APPEND\n");
                        free_value(&value);
                        free_value(&list_val);
                        goto cleanup;
                    }
                    list->items = new_items;
                    list->cap = new_cap;
                }
                
                // Append the value
                list->items[list->size] = copy_value(value);
                list->size++;
                
                // Push the list back on stack
                push_handle(list);
                retain_obj(list);
                
                free_value(&value);
                free_value(&list_val);
                break;
            }
            
            case OP_LIST_GET: {
                // List get: takes a list and an index, returns the element
                if (stack_top < 2) {
                    printf("Runtime error: LIST_GET requires list and index on stack\n");
                    goto cleanup;
                }
                
                stack_value_t index_val = pop_value();
                stack_value_t list_val = pop_value();
                
                if (list_val.type != RT_VAR_HANDLE || index_val.type != RT_VAR_INT) {
                    printf("Runtime error: LIST_GET requires list and integer index\n");
                    free_value(&index_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                rt_list_t *list = (rt_list_t *)list_val.value.handle_ptr;
                if (!list || list->hdr.type != OBJ_LIST) {
                    printf("Runtime error: LIST_GET first argument must be a list\n");
                    free_value(&index_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                int index = index_val.value.int_value;
                if (index < 0 || index >= list->size) {
                    printf("Runtime error: LIST_GET index %d out of bounds (size %d)\n", index, list->size);
                    free_value(&index_val);
                    free_value(&list_val);
                    goto cleanup;
                }
                
                // Push the element
                stack_value_t element = copy_value(list->items[index]);
                if (element.type == RT_VAR_INT) push_int(element.value.int_value);
                else if (element.type == RT_VAR_FLOAT) push_float(element.value.float_value);
                else if (element.type == RT_VAR_STRING) push_string(element.value.string_value);
                else if (element.type == RT_VAR_HANDLE) push_handle(element.value.handle_ptr);
                else push_null();
                
                free_value(&index_val);
                free_value(&list_val);
                break;
            }
            
            case OP_SET_ADD: {
                // Set add: takes a set and a value, adds value to set
                if (stack_top < 2) {
                    printf("Runtime error: SET_ADD requires set and value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                stack_value_t set_val = pop_value();
                
                if (set_val.type != RT_VAR_HANDLE) {
                    printf("Runtime error: SET_ADD first argument must be a set\n");
                    free_value(&value);
                    free_value(&set_val);
                    goto cleanup;
                }
                
                rt_set_t *set = (rt_set_t *)set_val.value.handle_ptr;
                if (!set || set->hdr.type != OBJ_SET) {
                    printf("Runtime error: SET_ADD first argument must be a set\n");
                    free_value(&value);
                    free_value(&set_val);
                    goto cleanup;
                }
                
                // Check if value already exists (simplified comparison)
                int found = 0;
                for (int i = 0; i < set->size && !found; i++) {
                    if (set->items[i].type == value.type) {
                        if (value.type == RT_VAR_INT && set->items[i].value.int_value == value.value.int_value) found = 1;
                        else if (value.type == RT_VAR_STRING && mod_strcmp(set->items[i].value.string_value, value.value.string_value) == 0) found = 1;
                    }
                }
                
                if (!found) {
                    // Expand set if needed
                    if (set->size >= set->cap) {
                        int new_cap = set->cap * 2;
                        stack_value_t *new_items = (stack_value_t *)mod_realloc(set->items, sizeof(stack_value_t) * new_cap);
                        if (!new_items) {
                            printf("Runtime error: Failed to expand set for SET_ADD\n");
                            free_value(&value);
                            free_value(&set_val);
                            goto cleanup;
                        }
                        set->items = new_items;
                        set->cap = new_cap;
                    }
                    
                    set->items[set->size] = copy_value(value);
                    set->size++;
                }
                
                // Push set back on stack
                push_handle(set);
                retain_obj(set);
                
                free_value(&value);
                free_value(&set_val);
                break;
            }
            
            case OP_SET_CONTAINS: {
                // Set contains: takes a set and a value, returns boolean
                if (stack_top < 2) {
                    printf("Runtime error: SET_CONTAINS requires set and value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                stack_value_t set_val = pop_value();
                
                if (set_val.type != RT_VAR_HANDLE) {
                    printf("Runtime error: SET_CONTAINS first argument must be a set\n");
                    free_value(&value);
                    free_value(&set_val);
                    goto cleanup;
                }
                
                rt_set_t *set = (rt_set_t *)set_val.value.handle_ptr;
                if (!set || set->hdr.type != OBJ_SET) {
                    printf("Runtime error: SET_CONTAINS first argument must be a set\n");
                    free_value(&value);
                    free_value(&set_val);
                    goto cleanup;
                }
                
                // Check if value exists
                int found = 0;
                for (int i = 0; i < set->size && !found; i++) {
                    if (set->items[i].type == value.type) {
                        if (value.type == RT_VAR_INT && set->items[i].value.int_value == value.value.int_value) found = 1;
                        else if (value.type == RT_VAR_STRING && mod_strcmp(set->items[i].value.string_value, value.value.string_value) == 0) found = 1;
                    }
                }
                
                push_int(found ? 1 : 0);
                
                free_value(&value);
                free_value(&set_val);
                break;
            }
            
            case OP_STRING_INTERPOLATE: {
                // String interpolation: takes a template string and variables
                // For now, just return the template string as-is
                if (stack_top < 1) {
                    printf("Runtime error: STRING_INTERPOLATE requires template on stack\n");
                    goto cleanup;
                }
                
                stack_value_t template = pop_value();
                if (template.type == RT_VAR_STRING) {
                    push_string(template.value.string_value);
                } else {
                    push_string("");
                }
                
                free_value(&template);
                break;
            }
            
            case OP_TYPEOF: {
                // Get type of value on stack
                if (stack_top < 1) {
                    printf("Runtime error: TYPEOF requires value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                
                switch (value.type) {
                    case RT_VAR_INT: push_string("int"); break;
                    case RT_VAR_FLOAT: push_string("float"); break;
                    case RT_VAR_STRING: push_string("string"); break;
                    case RT_VAR_HANDLE: push_string("handle"); break;
                    case RT_VAR_NULL: push_string("null"); break;
                    default: push_string("unknown"); break;
                }
                
                free_value(&value);
                break;
            }
            
            case OP_CAST: {
                // Cast value to different type
                if (stack_top < 2) {
                    printf("Runtime error: CAST requires value and target type on stack\n");
                    goto cleanup;
                }
                
                stack_value_t target_type = pop_value();
                stack_value_t value = pop_value();
                
                if (target_type.type != RT_VAR_STRING) {
                    printf("Runtime error: CAST target type must be string\n");
                    free_value(&target_type);
                    free_value(&value);
                    goto cleanup;
                }
                
                const char *type = target_type.value.string_value;
                
                if (mod_strcmp(type, "int") == 0) {
                    if (value.type == RT_VAR_FLOAT) push_int((int)value.value.float_value);
                    else if (value.type == RT_VAR_INT) push_int(value.value.int_value);
                    else push_int(0);
                } else if (mod_strcmp(type, "float") == 0) {
                    if (value.type == RT_VAR_INT) push_float((float)value.value.int_value);
                    else if (value.type == RT_VAR_FLOAT) push_float(value.value.float_value);
                    else push_float(0.0f);
                } else if (mod_strcmp(type, "string") == 0) {
                    if (value.type == RT_VAR_STRING) push_string(value.value.string_value);
                    else if (value.type == RT_VAR_INT) {
                        char buf[32];
                        mod_itoa(value.value.int_value, buf);
                        push_string(buf);
                    } else if (value.type == RT_VAR_FLOAT) {
                        char buf[32];
                        mod_ftoa(value.value.float_value, buf, 6);
                        push_string(buf);
                    } else push_string("");
                } else {
                    push_null();
                }
                
                free_value(&target_type);
                free_value(&value);
                break;
            }
            
            case OP_NEGATE: {
                // Unary negation
                if (stack_top < 1) {
                    printf("Runtime error: NEGATE requires value on stack\n");
                    goto cleanup;
                }
                
                stack_value_t value = pop_value();
                
                if (value.type == RT_VAR_INT) {
                    push_int(-value.value.int_value);
                } else if (value.type == RT_VAR_FLOAT) {
                    push_float(-value.value.float_value);
                } else {
                    printf("Runtime error: NEGATE requires numeric value\n");
                    free_value(&value);
                    goto cleanup;
                }
                
                free_value(&value);
                break;
            }
            
            case OP_EXIT:
                printf("Program completed successfully.\n");
                goto cleanup;
                
            case OP_AND:
                if (stack_top < 1) {
                    printf("Runtime error: Stack underflow in AND operation\n");
                    goto cleanup;
                }
                {
                    stack_value_t b = pop_value();
                    stack_value_t a = pop_value();
                    int res = (get_truth_value(a) && get_truth_value(b)) ? 1 : 0;
                    push_int(res);
                    free_value_shallow(a);
                    free_value_shallow(b);
                }
                break;
            
            case OP_OR:
                if (stack_top < 1) {
                    printf("Runtime error: Stack underflow in OR operation\n");
                    goto cleanup;
                }
                {
                    stack_value_t b = pop_value();
                    stack_value_t a = pop_value();
                    int res = (get_truth_value(a) || get_truth_value(b)) ? 1 : 0;
                    push_int(res);
                    free_value_shallow(a);
                    free_value_shallow(b);
                }
                break;
            
            case OP_NOT:
                if (stack_top < 0) {
                    printf("Runtime error: Stack underflow in NOT operation\n");
                    goto cleanup;
                }
                {
                    stack_value_t a = pop_value();
                    int res = !get_truth_value(a) ? 1 : 0;
                    push_int(res);
                    free_value_shallow(a);
                }
                break;
            
            case OP_POP:
                if (stack_top < 0) {
                    printf("Runtime error: Stack underflow in POP operation\n");
                    goto cleanup;
                }
                {
                    stack_value_t v = pop_value();
                    free_value_shallow(v);
                }
                break;
                
            default:
                printf("Runtime error: Unknown opcode %d at pc=%d\n", op, pc-1);
                goto cleanup;
        }
    }
    
cleanup:
    if (g_dbg_map) { mod_free(g_dbg_map); g_dbg_map=NULL; g_dbg_count=0; g_dbg_cap=0; }
    cleanup_runtime_vars();
    mod_free(code);
    if (data) mod_free(data);
    return 0;
}
