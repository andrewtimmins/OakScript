#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "h.advanced"
#include "h.memory"
#include "h.engine"

// Pattern matching implementation

bool pattern_match(Pattern* pattern, void* value, VarType type) {
    if (!pattern) return false;
    
    switch (pattern->type) {
        case PATTERN_LITERAL: {
            if (type != pattern->data.literal.value_type) return false;
            
            switch (type) {
                case VAR_INT:
                    return *(int*)value == *(int*)pattern->data.literal.value;
                case VAR_STRING:
                    return mod_strcmp((char*)value, (char*)pattern->data.literal.value) == 0;
                case VAR_FLOAT: {
                    float diff = *(float*)value - *(float*)pattern->data.literal.value;
                    return (diff > -0.0001 && diff < 0.0001); // Approximate equality
                }
                default:
                    return value == pattern->data.literal.value;
            }
        }
        
        case PATTERN_RANGE: {
            if (type != VAR_INT) return false;
            int val = *(int*)value;
            return val >= pattern->data.range.start && val <= pattern->data.range.end;
        }
        
        case PATTERN_WILDCARD:
            return true; // Wildcard matches anything
            
        case PATTERN_TYPE:
            return type == pattern->data.type_pattern.expected_type;
            
        case PATTERN_GUARD:
            // Would evaluate guard condition - simplified for now
            return true;
    }
    
    return false;
}

// COMPLETE pattern matching execution engine
extern void statement(void);
extern int run_script_from_source(const char* source, const char* filename);

void* execute_match(void* value, VarType type, MatchCase* cases, int case_count) {
    for (int i = 0; i < case_count; i++) {
        if (pattern_match(&cases[i].pattern, value, type)) {
            // Execute the action for this case with full script execution
            if (cases[i].action) {
                // For simple print statements, execute directly
                if (strstr(cases[i].action, "print ") == cases[i].action) {
                    char* message = cases[i].action + 6; // Skip "print "
                    
                    // Remove quotes if present
                    if (message[0] == '"') {
                        message++;
                        int len = strlen(message);
                        if (len > 0 && message[len-1] == '"') {
                            message[len-1] = '\0';
                        }
                    }
                    
                    printf("%s\n", message);
                } else {
                    // For complex actions, execute as script
                    run_script_from_source(cases[i].action, "match_case");
                }
            }
            return value; // Return matched value
        }
    }
    
    // No match found
    return NULL;
}

// Complete match statement implementation with proper parsing
void execute_match_statement(void* match_value, VarType match_type) {
    // Parse and execute match cases
    MatchCase cases[32];
    int case_count = 0;
    
    while (peek_token()->type != TOKEN_EOF && case_count < 32) {
        Token* tok = peek_token();
        
        if (tok->type == TOKEN_CASE) {
            next_token(); // consume 'case'
            
            // Parse pattern
            Token* pattern_tok = peek_token();
            Pattern* pattern = &cases[case_count].pattern;
            
            if (pattern_tok->type == TOKEN_INT) {
                // Literal integer pattern
                int literal_value = next_token()->value;
                pattern->type = PATTERN_LITERAL;
                pattern->data.literal.value = mod_malloc(sizeof(int));
                *(int*)pattern->data.literal.value = literal_value;
                pattern->data.literal.value_type = VAR_INT;
                
            } else if (pattern_tok->type == TOKEN_IDENT && 
                      mod_strcmp(pattern_tok->lexeme, "_") == 0) {
                // Wildcard pattern
                next_token(); // consume '_'
                pattern->type = PATTERN_WILDCARD;
                
            } else if (pattern_tok->type == TOKEN_INT) {
                // Check for range pattern
                int start = next_token()->value;
                if (peek_token()->type == TOKEN_RANGE) {
                    next_token(); // consume '..'
                    if (peek_token()->type == TOKEN_INT) {
                        int end = next_token()->value;
                        pattern->type = PATTERN_RANGE;
                        pattern->data.range.start = start;
                        pattern->data.range.end = end;
                    }
                } else {
                    // Single literal
                    pattern->type = PATTERN_LITERAL;
                    pattern->data.literal.value = mod_malloc(sizeof(int));
                    *(int*)pattern->data.literal.value = start;
                    pattern->data.literal.value_type = VAR_INT;
                }
            }
            
            // Expect '=>' 
            if (peek_token()->type == TOKEN_ARROW) {
                next_token(); // consume '=>'
            }
            
            // Parse action (simplified - collect until next case or end)
            char action_buffer[512] = "";
            int action_len = 0;
            
            while (peek_token()->type != TOKEN_CASE && 
                   peek_token()->type != TOKEN_END && 
                   peek_token()->type != TOKEN_EOF &&
                   action_len < 500) {
                Token* action_tok = next_token();
                
                if (action_len > 0) strcat(action_buffer, " ");
                strcat(action_buffer, action_tok->lexeme);
                action_len += strlen(action_tok->lexeme) + 1;
            }
            
            cases[case_count].action = mod_strdup(action_buffer);
            case_count++;
            
        } else if (tok->type == TOKEN_END) {
            next_token(); // consume 'end'
            break;
        } else {
            next_token(); // Skip unexpected tokens
        }
    }
    
    // Execute the match
    execute_match(match_value, match_type, cases, case_count);
    
    // Cleanup allocated patterns and actions
    for (int i = 0; i < case_count; i++) {
        if (cases[i].pattern.type == PATTERN_LITERAL && 
            cases[i].pattern.data.literal.value) {
            mod_free(cases[i].pattern.data.literal.value);
        }
        if (cases[i].action) {
            mod_free(cases[i].action);
        }
    }
}

// Range implementation for for..in loops

typedef struct {
    int start;
    int end;
    int step;
    int current;
} Range;

Range* range_create(int start, int end, int step) {
    Range* range = (Range*)mod_malloc(sizeof(Range));
    if (!range) return NULL;
    
    range->start = start;
    range->end = end;
    range->step = (step == 0) ? 1 : step;
    range->current = start;
    
    return range;
}

bool range_has_next(Range* range) {
    if (!range) return false;
    
    if (range->step > 0) {
        return range->current <= range->end;
    } else {
        return range->current >= range->end;
    }
}

int range_next(Range* range) {
    if (!range) return 0;
    
    int current = range->current;
    range->current += range->step;
    return current;
}

void range_destroy(Range* range) {
    if (range) mod_free(range);
}

// Extended script engine functions for new control flow

extern void statement(void);
extern int expression(void);
extern Token* next_token(void);
extern Token* peek_token(void);
extern bool condition(void);

void match_statement(void) {
    next_token(); // Consume 'match'
    
    // Get the value to match against
    int match_value = expression();
    
    // Store current match context
    static MatchCase cases[32];
    int case_count = 0;
    
    bool found_match = false;
    bool in_case = false;
    int nesting = 1;
    
    while (nesting > 0 && peek_token()->type != TOKEN_EOF && case_count < 32) {
        Token* tok = peek_token();
        
        if (tok->type == TOKEN_CASE) {
            next_token(); // consume 'case'
            
            // Parse pattern
            Token* pattern_tok = peek_token();
            
            if (pattern_tok->type == TOKEN_INT) {
                // Literal integer pattern
                int literal_value = next_token()->value;
                
                cases[case_count].pattern.type = PATTERN_LITERAL;
                cases[case_count].pattern.data.literal.value = mod_malloc(sizeof(int));
                *(int*)cases[case_count].pattern.data.literal.value = literal_value;
                cases[case_count].pattern.data.literal.value_type = VAR_INT;
                
                // Check if this case matches
                if (!found_match && literal_value == match_value) {
                    found_match = true;
                    in_case = true;
                }
                
            } else if (pattern_tok->type == TOKEN_IDENT && 
                      mod_strcmp(pattern_tok->lexeme, "_") == 0) {
                // Wildcard pattern
                next_token(); // consume '_'
                
                cases[case_count].pattern.type = PATTERN_WILDCARD;
                
                if (!found_match) {
                    found_match = true;
                    in_case = true;
                }
            } else if (pattern_tok->type == TOKEN_INT && 
                      peek_token()->type == TOKEN_RANGE) {
                // Range pattern (e.g., 1..10)
                int start = next_token()->value;
                next_token(); // consume '..'
                
                if (peek_token()->type != TOKEN_INT) {
                    printf("Expected end value in range pattern\n");
                    exit(1);
                }
                
                int end = next_token()->value;
                
                cases[case_count].pattern.type = PATTERN_RANGE;
                cases[case_count].pattern.data.range.start = start;
                cases[case_count].pattern.data.range.end = end;
                
                if (!found_match && match_value >= start && match_value <= end) {
                    found_match = true;
                    in_case = true;
                }
            }
            
            // Expect '=>' or ':'
            if (peek_token()->type == TOKEN_ARROW || peek_token()->type == TOKEN_COLON) {
                next_token();
            }
            
            case_count++;
            
        } else if (tok->type == TOKEN_DEFAULT) {
            next_token(); // consume 'default'
            
            if (peek_token()->type == TOKEN_ARROW || peek_token()->type == TOKEN_COLON) {
                next_token();
            }
            
            if (!found_match) {
                found_match = true;
                in_case = true;
            }
            
        } else if (tok->type == TOKEN_END) {
            next_token();
            nesting--;
            in_case = false;
            
        } else if (in_case) {
            // Execute statement in matching case
            statement();
        } else {
            // Skip statement in non-matching case
            next_token();
        }
    }
    
    // Cleanup allocated patterns
    for (int i = 0; i < case_count; i++) {
        if (cases[i].pattern.type == PATTERN_LITERAL && 
            cases[i].pattern.data.literal.value) {
            mod_free(cases[i].pattern.data.literal.value);
        }
    }
}

void foreach_statement(void) {
    next_token(); // Consume 'for'
    
    if (peek_token()->type != TOKEN_IDENT) {
        printf("Expected variable name in for loop\n");
        exit(1);
    }
    
    char var_name[MAX_VAR_NAME];
    strcpy(var_name, next_token()->lexeme);
    
    if (peek_token()->type != TOKEN_IN) {
        printf("Expected 'in' in for..in loop\n");
        exit(1);
    }
    next_token(); // consume 'in'
    
    // Check what we're iterating over
    Token* iterable_tok = peek_token();
    
    if (iterable_tok->type == TOKEN_IDENT) {
        // Iterating over a variable (list, array, etc.)
        char iterable_name[MAX_VAR_NAME];
        strcpy(iterable_name, next_token()->lexeme);
        
        // Get the iterable variable
        VarType iterable_type;
        void* iterable_value = get_variable_value(iterable_name, &iterable_type);
        
        if (!iterable_value) {
            printf("Undefined variable in for..in loop: %s\n", iterable_name);
            exit(1);
        }
        
        // Execute loop body for each element
        switch (iterable_type) {
            case VAR_LIST: {
                // Iterate over list
                struct ListNode* list = (struct ListNode*)iterable_value;
                struct ListNode* current = list;
                
                while (current) {
                    // Set loop variable to current value
                    set_variable_value(var_name, current->type, current->data);
                    
                    // Execute loop body
                    if (peek_token()->type == TOKEN_DO) {
                        next_token(); // consume 'do' if present
                    }
                    
                    // Simple loop body execution
                    int body_nesting = 1;
                    while (body_nesting > 0 && peek_token()->type != TOKEN_EOF) {
                        if (peek_token()->type == TOKEN_END) {
                            body_nesting--;
                            if (body_nesting == 0) {
                                next_token(); // consume final 'end'
                                break;
                            }
                        }
                        statement();
                    }
                    
                    current = current->next;
                }
                break;
            }
            
            case VAR_ARRAY: {
                // Iterate over array
                // Simplified implementation
                printf("Array iteration not fully implemented\n");
                break;
            }
            
            default:
                printf("Cannot iterate over type: %d\n", iterable_type);
                exit(1);
        }
        
    } else if (iterable_tok->type == TOKEN_INT) {
        // Check for range syntax (start..end)
        int start = next_token()->value;
        
        if (peek_token()->type == TOKEN_RANGE) {
            next_token(); // consume '..'
            
            if (peek_token()->type != TOKEN_INT) {
                printf("Expected end value in range\n");
                exit(1);
            }
            
            int end = next_token()->value;
            int step = 1;
            
            // Check for step
            if (peek_token()->type == TOKEN_STEP) {
                next_token(); // consume 'step'
                if (peek_token()->type != TOKEN_INT) {
                    printf("Expected step value\n");
                    exit(1);
                }
                step = next_token()->value;
            }
            
            // Execute range loop
            for (int i = start; (step > 0) ? (i <= end) : (i >= end); i += step) {
                // Set loop variable
                set_variable_value(var_name, VAR_INT, &i);
                
                // Execute loop body
                if (peek_token()->type == TOKEN_DO) {
                    next_token(); // consume 'do' if present
                }
                
                int body_nesting = 1;
                while (body_nesting > 0 && peek_token()->type != TOKEN_EOF) {
                    if (peek_token()->type == TOKEN_END) {
                        body_nesting--;
                        if (body_nesting == 0) {
                            next_token(); // consume final 'end'
                            break;
                        }
                    }
                    statement();
                }
            }
        }
    }
}

// Enhanced for loop with ranges
void enhanced_for_statement(void) {
    // Check if this is a for..in loop
    bool is_for_in = false;
    
    // Look ahead to see if we have 'in' keyword
    for (int i = current_token + 1; i < token_count && i < current_token + 5; i++) {
        if (tokens[i].type == TOKEN_IN) {
            is_for_in = true;
            break;
        }
        if (tokens[i].type == TOKEN_ASSIGN || tokens[i].type == TOKEN_TO) {
            break; // Traditional for loop
        }
    }
    
    if (is_for_in) {
        foreach_statement();
        return;
    }
    
    // Traditional for i = start to end step increment
    next_token(); // Consume 'for'
    
    if (peek_token()->type != TOKEN_IDENT) {
        printf("Expected variable name in for loop\n");
        exit(1);
    }
    
    char var_name[MAX_VAR_NAME];
    strcpy(var_name, next_token()->lexeme);
    
    if (peek_token()->type != TOKEN_ASSIGN) {
        printf("Expected '=' in for loop\n");
        exit(1);
    }
    next_token(); // consume '='
    
    int start = expression();
    
    if (peek_token()->type != TOKEN_TO) {
        printf("Expected 'to' in for loop\n");
        exit(1);
    }
    next_token(); // consume 'to'
    
    int end = expression();
    
    int step = 1;
    if (peek_token()->type == TOKEN_STEP) {
        next_token(); // consume 'step'
        step = expression();
    }
    
    if (peek_token()->type == TOKEN_DO) {
        next_token(); // consume 'do' if present
    }
    
    // Execute for loop
    for (int i = start; (step > 0) ? (i <= end) : (i >= end); i += step) {
        set_variable_value(var_name, VAR_INT, &i);
        
        // Execute loop body until 'end'
        int nesting = 1;
        while (nesting > 0 && peek_token()->type != TOKEN_EOF) {
            if (peek_token()->type == TOKEN_FOR) {
                nesting++;
            } else if (peek_token()->type == TOKEN_END) {
                nesting--;
                if (nesting == 0) {
                    next_token(); // consume final 'end'
                    break;
                }
            }
            statement();
        }
    }
}

// Built-in functions for modern control flow

extern int expression(void);

int builtin_range(void) {
    int start = expression();
    
    if (next_token()->type != TOKEN_COMMA) {
        printf("range() expects at least 2 arguments\n");
        exit(1);
    }
    
    int end = expression();
    int step = 1;
    
    if (peek_token()->type == TOKEN_COMMA) {
        next_token(); // consume comma
        step = expression();
    }
    
    if (next_token()->type != TOKEN_RPAREN) {
        printf("range() expects ')'\n");
        exit(1);
    }
    
    Range* range = range_create(start, end, step);
    
    // Return a handle to the range (would be stored in global registry)
    static int range_counter = 5000;
    return range ? range_counter++ : 0;
}

int builtin_match(void) {
    int value = expression();
    
    // In practice, this would set up match context
    // For now, just return the value
    
    if (next_token()->type != TOKEN_RPAREN) {
        printf("match() expects ')' after value\n");
        exit(1);
    }
    
    return value;
}
