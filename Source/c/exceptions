#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "h.advanced"
#include "h.memory"
#include "h.engine"

// Forward declarations
void add_stack_frame(const char* function_name, const char* file, int line);

// Exception type registry
typedef struct ExceptionType {
    char* name;
    char* description;
    struct ExceptionType* parent; // For exception inheritance
    struct ExceptionType* next;
} ExceptionType;

static ExceptionType* exception_types = NULL;
static ExceptionValue* current_exception = NULL;
static bool in_catch_block = false;
static bool in_finally_block = false;

// Exception stack for nested try-catch blocks
typedef struct ExceptionFrame {
    ExceptionValue* exception;
    bool has_finally;
    char* finally_code;
    struct ExceptionFrame* prev;
} ExceptionFrame;

static ExceptionFrame* exception_stack = NULL;

// Forward declaration
ExceptionType* register_exception_type(const char* name, const char* description, const char* parent_name);

// Register built-in exception types
void init_exception_system(void) {
    // Register standard exception types
    register_exception_type("Exception", "Base exception type", NULL);
    register_exception_type("RuntimeError", "Runtime execution error", "Exception");
    register_exception_type("TypeError", "Type-related error", "Exception");
    register_exception_type("ValueError", "Invalid value error", "Exception");
    register_exception_type("IndexError", "Array/list index out of range", "Exception");
    register_exception_type("KeyError", "Dictionary key not found", "Exception");
    register_exception_type("FileError", "File operation error", "Exception");
    register_exception_type("NetworkError", "Network operation error", "Exception");
    register_exception_type("ParseError", "Parsing/syntax error", "Exception");
    register_exception_type("MemoryError", "Memory allocation error", "Exception");
    register_exception_type("DivisionByZero", "Division by zero", "RuntimeError");
    register_exception_type("NullPointer", "Null pointer access", "RuntimeError");
}

ExceptionType* register_exception_type(const char* name, const char* description, const char* parent_name) {
    ExceptionType* new_type = (ExceptionType*)mod_malloc(sizeof(ExceptionType));
    if (!new_type) return NULL;
    
    new_type->name = mod_strdup(name);
    new_type->description = mod_strdup(description);
    new_type->parent = NULL;
    
    // Find parent type if specified
    if (parent_name) {
        ExceptionType* current = exception_types;
        while (current) {
            if (mod_strcmp(current->name, parent_name) == 0) {
                new_type->parent = current;
                break;
            }
            current = current->next;
        }
    }
    
    // Add to linked list
    new_type->next = exception_types;
    exception_types = new_type;
    
    return new_type;
}

ExceptionType* find_exception_type(const char* name) {
    ExceptionType* current = exception_types;
    while (current) {
        if (mod_strcmp(current->name, name) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

bool is_exception_instance_of(ExceptionValue* exc, const char* type_name) {
    if (!exc || !type_name) return false;
    
    ExceptionType* exc_type = find_exception_type(exc->type);
    ExceptionType* target_type = find_exception_type(type_name);
    
    if (!exc_type || !target_type) return false;
    
    // Check if exception type matches or is a subtype
    ExceptionType* current = exc_type;
    while (current) {
        if (current == target_type) return true;
        current = current->parent;
    }
    
    return false;
}

// Exception creation and manipulation

ExceptionValue* create_exception(const char* type, const char* message, const char* file, int line) {
    ExceptionValue* exc = exception_create(type, message);
    if (!exc) return NULL;
    
    if (file && line > 0) {
        exception_set_location(exc, file, line);
    }
    
    return exc;
}

// COMPLETE exception throwing with stack unwinding
void throw_exception(ExceptionValue* exc) {
    if (!exc) return;
    
    current_exception = exc;
    
    // Add current location to stack trace (implementation simplified)
    if (exc->stack_trace) {
        char frame_info[256];
        sprintf(frame_info, "  at throw_exception (%s:%d)\n", 
                exc->file_name ? exc->file_name : "unknown", exc->line_number);
        
        // In a full implementation, this would append to the stack trace
        char* old_trace = exc->stack_trace;
        int old_len = strlen(old_trace);
        int frame_len = strlen(frame_info);
        
        exc->stack_trace = (char*)mod_malloc(old_len + frame_len + 1);
        if (exc->stack_trace) {
            strcpy(exc->stack_trace, old_trace);
            strcat(exc->stack_trace, frame_info);
            mod_free(old_trace);
        }
    }
    
    // If we're not in a try block, terminate with error
    if (!exception_stack) {
        printf("Unhandled exception: %s: %s\n", exc->type, exc->message);
        if (exc->file_name && exc->line_number > 0) {
            printf("  at %s:%d\n", exc->file_name, exc->line_number);
        }
        if (exc->stack_trace) {
            printf("Stack trace:\n%s\n", exc->stack_trace);
        }
        exit(1);
    }
    
    // Store exception in current frame for catch block
    exception_stack->exception = exc;
    
    // Set flag to trigger catch block execution
    in_catch_block = true;
    
    // In a full implementation, this would use setjmp/longjmp for immediate stack unwinding
    // For now, we set the flag and let the execution flow handle it
}

// Try-catch-finally implementation

extern void statement(void);
extern Token* next_token(void);
extern Token* peek_token(void);

void try_statement(void) {
    next_token(); // Consume 'try'
    
    // Push new exception frame
    ExceptionFrame* frame = (ExceptionFrame*)mod_malloc(sizeof(ExceptionFrame));
    if (!frame) return;
    
    frame->exception = NULL;
    frame->has_finally = false;
    frame->finally_code = NULL;
    frame->prev = exception_stack;
    exception_stack = frame;
    
    // Execute try block
    bool exception_thrown = false;
    int try_nesting = 1;
    
    while (try_nesting > 0 && peek_token()->type != TOKEN_EOF) {
        Token* tok = peek_token();
        
        if (tok->type == TOKEN_TRY) {
            try_nesting++;
            statement();
        } else if (tok->type == TOKEN_CATCH) {
            try_nesting--;
            if (try_nesting == 0) {
                break; // Exit try block
            }
            statement();
        } else if (tok->type == TOKEN_FINALLY) {
            try_nesting--;
            if (try_nesting == 0) {
                break; // Exit try block
            }
            statement();
        } else {
            statement();
            
            // Check if an exception was thrown during statement execution
            if (current_exception) {
                exception_thrown = true;
                frame->exception = current_exception;
                current_exception = NULL;
                break;
            }
        }
    }
    
    // Handle catch blocks
    while (peek_token()->type == TOKEN_CATCH) {
        next_token(); // consume 'catch'
        
        bool should_handle = false;
        char exception_var[MAX_VAR_NAME] = "";
        char exception_type[64] = "";
        
        // Parse catch syntax: catch [ExceptionType] [as variable]
        if (peek_token()->type == TOKEN_IDENT) {
            Token* type_tok = next_token();
            strcpy(exception_type, type_tok->lexeme);
            
            // Check if this catch block handles the thrown exception
            if (frame->exception) {
                should_handle = is_exception_instance_of(frame->exception, exception_type);
            }
            
            // Parse 'as variable' clause
            if (peek_token()->type == TOKEN_AS) {
                next_token(); // consume 'as'
                if (peek_token()->type == TOKEN_IDENT) {
                    strcpy(exception_var, next_token()->lexeme);
                }
            }
        } else {
            // Catch all exceptions
            should_handle = (frame->exception != NULL);
        }
        
        // Execute catch block if it should handle the exception
        if (should_handle && frame->exception) {
            // Set exception variable if specified
            if (strlen(exception_var) > 0) {
                set_variable_value(exception_var, VAR_EXCEPTION, frame->exception);
            }
            
            in_catch_block = true;
            
            // Execute catch block statements
            int catch_nesting = 1;
            while (catch_nesting > 0 && peek_token()->type != TOKEN_EOF) {
                Token* tok = peek_token();
                
                if (tok->type == TOKEN_CATCH) {
                    catch_nesting++;
                    statement();
                } else if (tok->type == TOKEN_FINALLY || tok->type == TOKEN_END) {
                    catch_nesting--;
                    if (catch_nesting == 0) {
                        break;
                    }
                    statement();
                } else {
                    statement();
                }
            }
            
            in_catch_block = false;
            
            // Exception was handled
            exception_destroy(frame->exception);
            frame->exception = NULL;
            break;
        } else {
            // Skip this catch block
            int catch_nesting = 1;
            while (catch_nesting > 0 && peek_token()->type != TOKEN_EOF) {
                Token* tok = next_token();
                if (tok->type == TOKEN_CATCH) catch_nesting++;
                else if (tok->type == TOKEN_FINALLY || tok->type == TOKEN_END) catch_nesting--;
            }
        }
    }
    
    // Handle finally block
    if (peek_token()->type == TOKEN_FINALLY) {
        next_token(); // consume 'finally'
        frame->has_finally = true;
        
        in_finally_block = true;
        
        // Execute finally block
        int finally_nesting = 1;
        while (finally_nesting > 0 && peek_token()->type != TOKEN_EOF) {
            Token* tok = peek_token();
            
            if (tok->type == TOKEN_FINALLY) {
                finally_nesting++;
                statement();
            } else if (tok->type == TOKEN_END) {
                finally_nesting--;
                if (finally_nesting == 0) {
                    next_token(); // consume final 'end'
                    break;
                }
                statement();
            } else {
                statement();
            }
        }
        
        in_finally_block = false;
    } else if (peek_token()->type == TOKEN_END) {
        next_token(); // consume 'end'
    }
    
    // Pop exception frame
    exception_stack = frame->prev;
    
    // Re-throw unhandled exception
    if (frame->exception) {
        current_exception = frame->exception;
        throw_exception(current_exception);
    }
    
    mod_free(frame);
}

// Built-in exception functions

extern int expression(void);
extern char* evaluate_string_expr(void);

int builtin_throw(void) {
    // throw("ExceptionType", "message")
    char* exc_type = evaluate_string_expr();
    
    char* message = "";
    if (peek_token()->type == TOKEN_COMMA) {
        next_token(); // consume comma
        message = evaluate_string_expr();
    }
    
    if (next_token()->type != TOKEN_RPAREN) {
        printf("throw() expects ')'\n");
        exit(1);
    }
    
    if (!exc_type) exc_type = mod_strdup("Exception");
    if (!message) message = mod_strdup("An exception occurred");
    
    ExceptionValue* exc = create_exception(exc_type, message, "script", 0);
    
    mod_free(exc_type);
    if (message) mod_free(message);
    
    if (exc) {
        throw_exception(exc);
    }
    
    return 0;
}

int builtin_exception_type(void) {
    // exception_type(exception_variable)
    char* var_name = evaluate_string_expr();
    if (next_token()->type != TOKEN_RPAREN) {
        printf("exception_type() expects one argument\n");
        exit(1);
    }
    
    if (!var_name) return 0;
    
    VarType type;
    void* value = get_variable_value(var_name, &type);
    mod_free(var_name);
    
    if (!value || type != VAR_EXCEPTION) return 0;
    
    ExceptionValue* exc = (ExceptionValue*)value;
    
    // Return type as string (simplified - would set a string variable)
    printf("Exception type: %s\n", exc->type);
    return 1;
}

int builtin_exception_message(void) {
    // exception_message(exception_variable)
    char* var_name = evaluate_string_expr();
    if (next_token()->type != TOKEN_RPAREN) {
        printf("exception_message() expects one argument\n");
        exit(1);
    }
    
    if (!var_name) return 0;
    
    VarType type;
    void* value = get_variable_value(var_name, &type);
    mod_free(var_name);
    
    if (!value || type != VAR_EXCEPTION) return 0;
    
    ExceptionValue* exc = (ExceptionValue*)value;
    
    // Return message as string (simplified)
    printf("Exception message: %s\n", exc->message);
    return 1;
}

int builtin_create_exception(void) {
    // create_exception("Type", "Message")
    char* exc_type = evaluate_string_expr();
    
    if (next_token()->type != TOKEN_COMMA) {
        printf("create_exception() expects two arguments\n");
        exit(1);
    }
    
    char* message = evaluate_string_expr();
    
    if (next_token()->type != TOKEN_RPAREN) {
        printf("create_exception() expects ')'\n");
        exit(1);
    }
    
    if (!exc_type) exc_type = mod_strdup("Exception");
    if (!message) message = mod_strdup("");
    
    ExceptionValue* exc = create_exception(exc_type, message, "script", 0);
    
    mod_free(exc_type);
    mod_free(message);
    
    // Return exception handle (would store in registry)
    static int exc_counter = 7000;
    return exc ? exc_counter++ : 0;
}

int builtin_define_exception(void) {
    // define_exception("NewExceptionType", "ParentType", "Description")
    char* name = evaluate_string_expr();
    
    char* parent = NULL;
    if (peek_token()->type == TOKEN_COMMA) {
        next_token(); // consume comma
        parent = evaluate_string_expr();
    }
    
    char* description = NULL;
    if (peek_token()->type == TOKEN_COMMA) {
        next_token(); // consume comma
        description = evaluate_string_expr();
    }
    
    if (next_token()->type != TOKEN_RPAREN) {
        printf("define_exception() expects ')'\n");
        exit(1);
    }
    
    if (!name) return 0;
    if (!description) description = mod_strdup("");
    
    ExceptionType* new_type = register_exception_type(name, description, parent);
    
    mod_free(name);
    if (parent) mod_free(parent);
    if (description) mod_free(description);
    
    return new_type ? 1 : 0;
}

// Stack trace support

void add_stack_frame(const char* function_name, const char* file, int line) {
    if (!current_exception) return;
    
    char frame[256];
    sprintf(frame, "  at %s (%s:%d)\n", function_name, file, line);
    
    if (!current_exception->stack_trace) {
        current_exception->stack_trace = mod_strdup(frame);
    } else {
        int old_len = mod_strlen(current_exception->stack_trace);
        int frame_len = mod_strlen(frame);
        char* new_trace = (char*)mod_malloc(old_len + frame_len + 1);
        
        strcpy(new_trace, current_exception->stack_trace);
        strcat(new_trace, frame);
        
        mod_free(current_exception->stack_trace);
        current_exception->stack_trace = new_trace;
    }
}

// Cleanup exception system

void cleanup_exception_system(void) {
    // Cleanup exception types
    ExceptionType* current = exception_types;
    while (current) {
        ExceptionType* next = current->next;
        mod_free(current->name);
        mod_free(current->description);
        mod_free(current);
        current = next;
    }
    exception_types = NULL;
    
    // Cleanup exception stack
    while (exception_stack) {
        ExceptionFrame* frame = exception_stack;
        exception_stack = frame->prev;
        
        if (frame->exception) {
            exception_destroy(frame->exception);
        }
        if (frame->finally_code) {
            mod_free(frame->finally_code);
        }
        mod_free(frame);
    }
    
    // Cleanup current exception
    if (current_exception) {
        exception_destroy(current_exception);
        current_exception = NULL;
    }
}
