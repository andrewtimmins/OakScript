// Header file for OakScript Compiler and Bytecode Runtime
#ifndef OAKSCRIPT_COMPILE_H
#define OAKSCRIPT_COMPILE_H

/* OakScript Bytecode Format */

// Bytecode file header
typedef struct {
    char magic[8];          // "OAKSCODE"
    unsigned int version;   // Bytecode format version
    unsigned int code_size; // Size of bytecode section
    unsigned int data_size; // Size of string/constant data section
} oakscode_header_t;

// Bytecode instruction opcodes
typedef enum {
    OP_NOP = 0,
    OP_LOAD_INT,        // Load integer constant
    OP_LOAD_FLOAT,      // Load float constant  
    OP_LOAD_STRING,     // Load string constant
    OP_LOAD_VAR,        // Load variable value by name
    OP_STORE_VAR,       // Store top of stack to variable by name
    OP_PRINT_INT,       // Print integer value
    OP_PRINT_STRING,    // Print string value
    OP_ADD,             // Add two values
    OP_SUB,             // Subtract
    OP_MUL,             // Multiply
    OP_DIV,             // Divide
    OP_CMP_EQ,          // Compare equal (==)
    OP_CMP_NE,          // Compare not equal (!=)
    OP_CMP_LT,          // Compare less than (<)
    OP_CMP_LE,          // Compare less than or equal (<=)
    OP_CMP_GT,          // Compare greater than (>)
    OP_CMP_GE,          // Compare greater than or equal (>=)
    OP_PRINT,           // Print statement (deprecated - use PRINT_INT/PRINT_STRING)
    OP_CALL,            // Generic function call (deprecated)
    OP_CALL_BUILTIN,    // Call built-in function
    OP_CALL_USER,       // Call user-defined function
    OP_RETURN,          // Return from function
    OP_JUMP,            // Unconditional jump to address
    OP_JUMP_IF_FALSE,   // Conditional jump if top of stack is false/zero
    OP_JUMP_FALSE,      // Alias for OP_JUMP_IF_FALSE (compatibility)
    OP_POP,             // Pop top value from stack
    OP_TRY,             // Push try handler address onto try stack
    OP_END_TRY,         // Pop try handler (normal exit from try)
    OP_THROW,           // Throw exception (jump to nearest handler)
    OP_LOOP_START,      // Mark loop start for while/for
    OP_LOOP_END,        // Mark loop end and jump back to start
    
    // Advanced control flow
    OP_SWITCH,          // Switch statement start
    OP_CASE,            // Case comparison
    OP_DEFAULT,         // Default case
    OP_MATCH,           // Pattern matching
    OP_FOR_IN,          // For-in loop over collection
    OP_BREAK,           // Break from loop
    OP_CONTINUE,        // Continue loop
    
    // Data structure operations
    OP_DICT_CREATE,     // Create dictionary
    OP_DICT_SET,        // Set dictionary key-value
    OP_DICT_GET,        // Get dictionary value
    OP_LIST_CREATE,     // Create list
    OP_LIST_APPEND,     // Append to list
    OP_LIST_GET,        // Get list element
    OP_SET_CREATE,      // Create set
    OP_SET_ADD,         // Add to set
    OP_SET_CONTAINS,    // Check set membership
    
    // Functional programming
    OP_LAMBDA_CREATE,   // (Deprecated) legacy placeholder for lambda; use OP_CALL_BUILTIN "lambda"
    OP_LAMBDA_CALL,     // Call lambda function
    OP_MAP,             // Map operation
    OP_FILTER,          // Filter operation
    OP_REDUCE,          // Reduce operation
    
    // String processing
    OP_STRING_INTERPOLATE, // String interpolation
    OP_STRING_MULTILINE,   // Multi-line string
    OP_REGEX_COMPILE,      // Compile regex
    OP_REGEX_MATCH,        // Match regex
    OP_REGEX_REPLACE,      // Replace with regex
    
    // Type system
    OP_TYPEOF,          // Get type of value
    OP_CAST,            // Cast value to type
    OP_IS_TYPE,         // Check if value is type
    OP_OPTIONAL_CREATE, // Create optional value
    OP_UNION_CREATE,    // Create union value
    
    // Enhanced expressions
    OP_AND,             // Logical AND
    OP_OR,              // Logical OR
    OP_NOT,             // Logical NOT
    OP_NEGATE,          // Unary negation
    OP_INCREMENT,       // Increment variable
    OP_DECREMENT,       // Decrement variable
    
    OP_EXIT             // End program
} opcode_t;

/*
 * OP_CALL_BUILTIN calling convention (updated for unified bridge model):
 *   Encoding: [OP_CALL_BUILTIN][string_ref builtin_name][int arg_count]
 *   Stack before execution: arg1, arg2, ..., argN  (pushed in left-to-right order)
 *   Execution:
 *     - VM pops N values into a temporary array preserving original order.
 *     - Converts them to bridge_value_t and calls bridge_dispatch(builtin_name,...).
 *     - On success: pushes exactly one result value (or a null placeholder if builtin returns void).
 *     - On bridge error: creates/throws BuiltinError (current exception set) and pushes null (or implementation-defined) so control flow may continue if caught.
 *   Notes:
 *     - Adding a new builtin requires no opcode changes; only runtime bridge support + compiler name table entry.
 *     - Some legacy specialized opcodes remain for performance (e.g., arithmetic, comparisons, LOAD/STORE); advanced features converge here.
 */

// Function prototypes
extern int compile_script_to_bytecode(const char *source_file, const char *output_file);

#endif // OAKSCRIPT_COMPILE_H
