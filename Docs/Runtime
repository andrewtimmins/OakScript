OakScript Runtime Architecture Documentation
===========================================

Version: 1.0
Date: 2024

OVERVIEW
--------

The OakScript runtime is a stack-based virtual machine that executes bytecode
generated by the OakScript compiler. It provides a complete execution environment
with variable management, built-in function support, and memory-safe operations
suitable for the RISC OS platform.

RUNTIME ARCHITECTURE
--------------------

The runtime consists of several key components:

1. VIRTUAL MACHINE: Core execution engine
2. EXECUTION STACK: Value storage for expressions
3. VARIABLE STORAGE: Dynamic variable management
4. BUILT-IN FUNCTIONS: Pre-defined function library
5. MEMORY MANAGER: Module-safe memory allocation
6. ERROR HANDLING: Runtime error management

VIRTUAL MACHINE DESIGN
---------------------

The VM uses a stack-based execution model similar to the JVM or .NET CLR:

Core Components:
- Program Counter (PC): Current instruction pointer
- Execution Stack: LIFO stack for operands
- Variable Table: Dynamic key-value storage
- Instruction Decoder: Opcode interpretation
- Memory Manager: Safe allocation/deallocation

Execution Cycle:
1. Load bytecode file and validate header
2. Initialize runtime structures
3. Execute instruction at PC
4. Update PC to next instruction
5. Repeat until OP_EXIT or error
6. Cleanup and report results

EXECUTION STACK
--------------

The execution stack stores intermediate values during expression evaluation:

Stack Value Structure:
    typedef struct {
        stack_value_type_t type;    // TYPE_INT or TYPE_STRING
        union {
            int int_value;
            char* string_value;
        } data;
    } stack_value_t;

Stack Operations:

push_int(stack, value):
- Allocates new stack entry
- Sets type to TYPE_INT
- Stores integer value
- Increments stack pointer

push_string(stack, value):
- Allocates new stack entry  
- Sets type to TYPE_STRING
- Copies string using mod_strcpy
- Increments stack pointer

pop_value(stack):
- Returns top stack value
- Decrements stack pointer
- Caller responsible for memory cleanup
- Returns NULL on stack underflow

Stack Management:
- Dynamic growth as needed
- Automatic cleanup on errors
- Type safety enforcement
- Bounds checking

VARIABLE STORAGE
---------------

Variables are stored in a dynamic table with string keys:

Variable Structure:
    typedef struct {
        char* name;                    // Variable name
        runtime_var_type_t type;       // TYPE_INT or TYPE_STRING  
        union {
            int int_value;
            char* string_value;
        } value;
    } runtime_variable_t;

Variable Operations:

store_variable(name, stack_value):
- Searches for existing variable by name
- Creates new variable if not found
- Updates value and type from stack value
- Handles string memory allocation
- Uses mod_malloc for safety

load_variable(name):
- Linear search through variable table
- Returns stack_value_t copy of variable
- Handles string duplication
- Returns error for undefined variables

Variable Scope:
- All variables are currently global
- Future: Function-local scoping
- Future: Block-level scoping
- Future: Closure support

Memory Management:
- Variable names allocated with mod_malloc
- String values allocated with mod_malloc
- Automatic cleanup on program exit
- Proper deallocation on variable updates

INSTRUCTION EXECUTION
--------------------

The runtime executes bytecode instructions through a large switch statement:

Instruction Decoder:
    switch (opcode) {
        case OP_LOAD_INT: ...
        case OP_ADD: ...
        default: runtime_error();
    }

Execution Examples:

OP_LOAD_INT:
1. Read 4-byte integer operand
2. Create stack_value_t with TYPE_INT
3. Push value onto execution stack
4. Advance PC by 5 bytes

OP_ADD:
1. Pop second operand (b) from stack
2. Pop first operand (a) from stack  
3. Validate both are TYPE_INT
4. Calculate result = a + b
5. Push result onto stack
6. Advance PC by 1 byte

OP_STORE_VAR:
1. Read 4-byte string offset operand
2. Resolve offset to variable name
3. Pop value from execution stack
4. Store value in variable table
5. Advance PC by 5 bytes

OP_CALL_BUILTIN:
1. Read 4-byte string offset operand
2. Resolve offset to function name
3. Dispatch to built-in function handler
4. Function pops arguments from stack
5. Function pushes result onto stack
6. Advance PC by 5 bytes

BUILT-IN FUNCTION SYSTEM
------------------------

Built-in functions provide core language functionality:

Function Dispatcher:
    if (mod_strcmp(func_name, "abs") == 0) {
        return builtin_abs();
    } else if (mod_strcmp(func_name, "min") == 0) {
        return builtin_min();
    } // ... etc

Implemented Functions:

abs(value):
- Pops one integer from stack
- Calculates absolute value
- Pushes result back to stack
- Validates argument count and type

min(a, b):
- Pops two integers from stack (b, then a)
- Calculates minimum of a and b
- Pushes result back to stack
- Validates argument count and type

max(a, b):
- Pops two integers from stack (b, then a)
- Calculates maximum of a and b
- Pushes result back to stack
- Validates argument count and type

file_exists():
- Takes no arguments from stack
- Returns 1 (true) - placeholder implementation
- Future: Check actual file existence
- Pushes integer result to stack

Function Call Protocol:
1. Arguments pushed to stack in order (left to right)
2. OP_CALL_BUILTIN references function by name
3. Function pops arguments in reverse order
4. Function validates argument count and types
5. Function pushes result (if any) to stack
6. Execution continues after call

CONTROL FLOW EXECUTION
---------------------

Control flow instructions manipulate the program counter:

Jump Instructions:

OP_JUMP:
1. Read 4-byte signed offset operand
2. Add offset to current PC
3. Continue execution at new location
4. Used for unconditional branches

OP_JUMP_IF_FALSE:
1. Pop condition value from stack
2. Read 4-byte signed offset operand
3. If condition is false/zero, add offset to PC
4. If condition is true/non-zero, advance PC normally
5. Used for if statements and loop exits

Conditional Execution Example:
    Source: if (x > 5) { print x }
    
    Bytecode execution:
    1. OP_LOAD_VAR "x"     // Push x value
    2. OP_LOAD_INT 5       // Push constant 5
    3. OP_CMP_GT           // Pop 5,x; push (x > 5)
    4. OP_JUMP_IF_FALSE 8  // Skip to after print if false
    5. OP_LOAD_VAR "x"     // Push x value
    6. OP_PRINT_INT        // Print x
    7. [next instruction]

Loop Execution Example:
    Source: while (x < 10) { x = x + 1 }
    
    Bytecode execution:
    1. loop_start: OP_LOAD_VAR "x"    // Push x
    2. OP_LOAD_INT 10                 // Push 10
    3. OP_CMP_LT                      // Push (x < 10)
    4. OP_JUMP_IF_FALSE loop_end      // Exit if false
    5. OP_LOAD_VAR "x"                // Push x
    6. OP_LOAD_INT 1                  // Push 1
    7. OP_ADD                         // Push (x + 1)
    8. OP_STORE_VAR "x"               // Store result
    9. OP_JUMP loop_start             // Repeat
    10. loop_end: [next instruction]

MEMORY MANAGEMENT
----------------

The runtime uses RISC OS module-safe memory functions exclusively with dynamic
allocation for optimal memory efficiency:

Memory Functions Used:
- mod_malloc(): Allocate memory blocks
- mod_free(): Deallocate memory blocks  
- mod_strcpy(): Safe string copying
- mod_strlen(): Safe string length
- mod_strncmp(): Safe string comparison

Dynamic Allocation Strategy (Version 0.05+):
- Variables: Dynamic array allocated during engine initialization
- Functions: Dynamic array allocated during engine initialization  
- Strings: Allocated and copied for safety
- Stack: Dynamic growth with reallocation
- Buffers: Fixed-size with bounds checking

Memory Safety Improvements:
- Eliminated large static arrays that caused module loading issues
- All global arrays now dynamically allocated via mod_malloc()
- Variables[MAX_VARS] and functions[MAX_VARS] moved to heap
- Stack-allocated backup arrays replaced with dynamic allocation
- Module initialization performs all array allocation with error handling

Allocation Process:
1. Module initialization calls init_script_engine()
2. init_script_engine() allocates variables and functions arrays
3. On allocation failure, module initialization fails gracefully
4. Arrays are zero-initialized for safe operation

Memory Safety Features:
- All pointers validated before use
- Automatic cleanup on program exit or module finalization
- Proper deallocation on variable updates
- No use of standard C library functions
- Dynamic allocation prevents stack overflow in function calls

Cleanup Process:
1. Free all variable names and string values
2. Free dynamically allocated variables and functions arrays
3. Free execution stack
4. Free any temporary allocations
5. Return memory to system via mod_shutdown()

ERROR HANDLING
-------------

The runtime implements comprehensive error checking:

Error Types:
- Stack underflow/overflow
- Invalid opcode
- Type mismatch in operations
- Undefined variable access
- Invalid function name
- Memory allocation failure
- File format errors

Error Reporting:
- Descriptive error messages
- Program counter information
- Stack state information
- Graceful termination
- Memory cleanup on errors

Error Examples:
- "Runtime error: Stack underflow"
- "Runtime error: Unknown opcode: 0x99"
- "Runtime error: abs() requires 1 argument"
- "Runtime error: Cannot add string and integer"
- "Runtime error: Undefined variable: foo"

FILE FORMAT VALIDATION
---------------------

The runtime validates bytecode files before execution:

Header Validation:
1. Check magic number "OAKSCODE"
2. Verify supported version number
3. Validate code and data sizes
4. Check file size consistency

Bytecode Validation:
- Verify all opcodes are valid
- Check operand sizes match expectations
- Validate string offsets point within data section
- Ensure jump targets are valid instruction boundaries

Data Section Validation:
- Verify all strings are null-terminated
- Check string offsets don't exceed section size
- Validate string encoding (ASCII/UTF-8)

PERFORMANCE CHARACTERISTICS
--------------------------

The runtime is optimized for simplicity over speed:

Performance Metrics:
- Variable lookup: O(n) linear search
- Function dispatch: O(n) string comparison
- Stack operations: O(1) amortized
- Memory allocation: O(1) via system

Optimization Opportunities:
- Hash tables for variable lookup
- Function pointer tables for dispatch
- Register-based VM instead of stack-based
- Just-in-time compilation

Memory Usage:
- Minimal overhead per variable
- Efficient string storage
- Dynamic stack growth
- No garbage collection needed

DEBUGGING SUPPORT
----------------

The runtime includes debugging features:

Execution Tracing:
- Optional instruction-by-instruction tracing
- Stack state dumping
- Variable table inspection
- Program counter tracking

Debug Output Example:
    PC: 0x04 OP_LOAD_INT 42
    Stack: [42]
    PC: 0x09 OP_STORE_VAR "x"  
    Variables: x=42
    Stack: []

Error Diagnostics:
- Complete stack trace on errors
- Variable state at time of error
- Instruction context information
- Memory usage statistics

INTEGRATION WITH RISC OS
------------------------

The runtime is designed for RISC OS module environment:

Module Integration:
- Callable via *OakScriptRun command
- Module-safe throughout
- Proper RISC OS error handling
- SWI integration for system calls

Command Interface:
    *OakScriptRun bytecode_file

File Handling:
- Automatic .eef file type recognition
- RISC OS path conventions
- Error reporting via standard channels

System Integration:
- Module memory management
- RISC OS file I/O
- System error codes
- Proper resource cleanup

CONCURRENCY CONSIDERATIONS
--------------------------

Current runtime is single-threaded:

Thread Safety:
- No global state shared between invocations
- Each execution has isolated variable space
- Module-safe memory allocation
- No static variables used

Future Concurrency:
- Multiple VM instances possible
- Shared built-in function implementations
- Thread-local variable storage
- Synchronized access to system resources

EXTENSIBILITY
------------

The runtime is designed for future expansion:

Plugin Architecture:
- Built-in functions easily added
- Opcode set extensible
- Module system for libraries
- Foreign function interface

Language Extensions:
- Object-oriented features
- Exception handling
- Coroutines/generators
- Native code integration

System Extensions:
- GUI integration
- Network operations
- Database connectivity
- Hardware access

TESTING AND VALIDATION
---------------------

Runtime testing includes:

Unit Tests:
- Individual instruction execution
- Stack operation validation
- Variable storage testing
- Built-in function verification

Integration Tests:
- Complete program execution
- Control flow validation
- Error handling verification
- Memory management testing

Stress Tests:
- Large variable tables
- Deep call stacks
- Long-running programs
- Memory allocation limits

Bytecode Validation:
- Malformed file handling
- Invalid opcode sequences
- Corrupted headers
- Invalid jump targets

RANDOM NUMBER GENERATION (DETERMINISTIC)
---------------------------------------

The runtime LCG provides deterministic 15-bit outputs (0..32767) via rand().

Seeding Rules:
- Default seed = 1.
- Environment overrides (first match wins): OakScript$Seed, then OAKS_SEED.
- srand(seed) explicitly sets the internal 32-bit state (zero allowed) without advancing it.
- rand(lo, hi) returns inclusive range; parameters swapped if reversed.
- rand_seed() (debug) exposes current internal state for tests.

Determinism Guidance:
- Use fixed seed (env or initial srand) for reproducible tests.
- Verbose sampling utilities snapshot/restore state to avoid perturbing sequences.

NUMERIC SEMANTICS & PARITY
--------------------------

Arithmetic Parity:
- VM opcodes ADD/SUB/MUL/DIV operate on ints/floats; mixed types promote to float.
- Division by zero triggers a runtime error; builtins divide()/mod() now mirror this (error instead of prior silent 0).
- pow(base, exp) with negative exp returns 0 (int exponent policy) pending future float exponent support.
- isqrt(n) returns 0 for n <= 0; clamp swaps bounds if lo > hi.

Planned Improvements:
- More specific BuiltinError messages (e.g., "division by zero").
- Float exponent support for pow.
- Configurable epsilon for float equality (currently 1e-6 absolute).

MEMORY / OBJECT AUDIT FACILITIES
--------------------------------

Diagnostics Builtins:
- debug_object_counts(): returns { total, type_#... } for non-zero categories.
- debug_object_audit(): returns { total, bad, zero_ref, neg_ref, null_hdr } summarizing anomalies.

Enumerator:
- Internal rt_object_enumerate walks registry O(N); intended for debugging, not production hot paths.

Usage Example:
```
let counts = debug_object_counts();
print(counts.total);
let audit = debug_object_audit();
if (audit.bad > 0) { print("Potential leaks or ownership issues detected"); }
```

Future Audit Enhancements:
- Allocation site tagging
- Peak usage snapshots
- Leak persistence tracking across runs

CONCLUSION
----------

The OakScript runtime provides a robust execution environment for OakScript
bytecode. The stack-based design is simple to understand and implement while
providing good performance for typical scripting tasks. The focus on memory
safety and RISC OS integration makes it suitable for production use in the
RISC OS environment. The modular design allows for future enhancements while
maintaining compatibility with existing bytecode programs.
