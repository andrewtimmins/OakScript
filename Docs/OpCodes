OakScript OpCode Reference Manual
=================================

Version: 1.0
Date: 2024

INTRODUCTION
-----------

This document provides a complete reference for all opcodes supported by the
OakScript virtual machine. Each opcode is documented with its encoding format,
stack effects, execution semantics, and usage examples.

OPCODE ENCODING
--------------

All opcodes are encoded as single bytes (0x00 to 0xFF) followed by optional
operands. Operands are encoded in little-endian format and may be integers,
floats, or string offsets depending on the instruction.

NOTATION CONVENTIONS
-------------------

Stack Notation:
- [before] → [after]
- Example: [a, b] → [result] means pop b, pop a, push result

Operand Types:
- int32: 32-bit signed integer
- offset32: 32-bit unsigned offset into string data section
- jump32: 32-bit signed jump offset

Size Notation:
- Bytes: Total instruction size including operands
- Example: "5 bytes" = 1 byte opcode + 4 byte operand

BASIC OPERATIONS
===============

OP_NOP (0x00)
-------------
No Operation

Encoding: [0x00]
Size: 1 byte
Stack: [] → []
Description: Does nothing. Used for padding or debugging.
Example: 0x00

OP_EXIT (0x01)
--------------
Exit Program

Encoding: [0x01]
Size: 1 byte
Stack: [] → []
Description: Terminates program execution immediately.
Example: 0x01

CONSTANT LOADING
===============

OP_LOAD_INT (0x10)
------------------
Load Integer Constant

Encoding: [0x10][int32_value]
Size: 5 bytes
Stack: [] → [int]
Description: Pushes a 32-bit signed integer constant onto the stack.

Example:
    Bytecode: 0x10 0x2A 0x00 0x00 0x00
    Effect: Pushes 42 onto stack
    Source: print 42

OP_LOAD_FLOAT (0x11)
--------------------
Load Floating-Point Constant

Encoding: [0x11][float32_value]
Size: 5 bytes
Stack: [] → [float]
Description: Pushes a 32-bit IEEE 754 float constant onto the stack.
Note: Currently not generated by compiler but reserved for future use.

Example:
    Bytecode: 0x11 0x00 0x00 0x20 0x41
    Effect: Pushes 10.0 onto stack

OP_LOAD_STRING (0x12)
---------------------
Load String Constant

Encoding: [0x12][offset32]
Size: 5 bytes
Stack: [] → [string]
Description: Pushes string from data section onto stack.

Example:
    Bytecode: 0x12 0x00 0x00 0x00 0x00
    Effect: Pushes string at offset 0 from data section
    Source: print "hello"

VARIABLE OPERATIONS
==================

OP_LOAD_VAR (0x20)
------------------
Load Variable Value

Encoding: [0x20][name_offset32]
Size: 5 bytes
Stack: [] → [value]
Description: Looks up variable by name and pushes its value onto stack.

Example:
    Bytecode: 0x20 0x06 0x00 0x00 0x00
    Effect: Loads variable named by string at offset 6
    Source: print x

Error Conditions:
- Runtime error if variable is undefined
- Type of pushed value depends on variable's stored type

OP_STORE_VAR (0x21)
-------------------
Store Variable Value

Encoding: [0x21][name_offset32]
Size: 5 bytes
Stack: [value] → []
Description: Pops value from stack and stores in named variable.

Example:
    Bytecode: 0x21 0x06 0x00 0x00 0x00
    Effect: Stores top stack value in variable at offset 6
    Source: x = 42

Notes:
- Creates variable if it doesn't exist
- Updates existing variable's value and type
- Handles automatic type conversion

OUTPUT OPERATIONS
================

OP_PRINT_INT (0x30)
-------------------
Print Integer

Encoding: [0x30]
Size: 1 byte
Stack: [int] → []
Description: Pops integer from stack and prints it to stdout.

Example:
    Bytecode: 0x30
    Effect: Prints top stack integer
    Source: print 42

Error Conditions:
- Runtime error if stack is empty
- Runtime error if top value is not integer

OP_PRINT_STRING (0x31)
----------------------
Print String

Encoding: [0x31]
Size: 1 byte
Stack: [string] → []
Description: Pops string from stack and prints it to stdout.

Example:
    Bytecode: 0x31
    Effect: Prints top stack string
    Source: print "hello"

Error Conditions:
- Runtime error if stack is empty
- Runtime error if top value is not string

ARITHMETIC OPERATIONS
====================

OP_ADD (0x40)
-------------
Addition

Encoding: [0x40]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a from stack, pushes (a + b).

Example:
    Bytecode: 0x40
    Effect: result = a + b
    Source: x + y

Evaluation Order:
    OP_LOAD_VAR "x"  // Push x (a)
    OP_LOAD_VAR "y"  // Push y (b)
    OP_ADD           // Pop y, pop x, push x+y

Error Conditions:
- Runtime error if fewer than 2 values on stack
- Runtime error if operands are not both integers

OP_SUB (0x41)
-------------
Subtraction

Encoding: [0x41]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a from stack, pushes (a - b).

Example:
    Bytecode: 0x41
    Effect: result = a - b
    Source: x - y

Notes:
- Order matters: first pushed value is left operand
- Second pushed value is right operand

OP_MUL (0x42)
-------------
Multiplication

Encoding: [0x42]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a from stack, pushes (a * b).

Example:
    Bytecode: 0x42
    Effect: result = a * b
    Source: x * y

OP_DIV (0x43)
-------------
Division

Encoding: [0x43]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a from stack, pushes (a / b).

Example:
    Bytecode: 0x43
    Effect: result = a / b
    Source: x / y

Error Conditions:
- Runtime error if divisor (b) is zero
- Integer division truncates toward zero

COMPARISON OPERATIONS
====================

All comparison operations pop two values and push 1 (true) or 0 (false).

OP_CMP_EQ (0x50)
----------------
Equal Comparison

Encoding: [0x50]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a == b, else 0.

Example:
    Bytecode: 0x50
    Effect: result = (a == b) ? 1 : 0
    Source: x == y

OP_CMP_NE (0x51)
----------------
Not Equal Comparison

Encoding: [0x51]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a != b, else 0.

Example:
    Bytecode: 0x51
    Effect: result = (a != b) ? 1 : 0
    Source: x != y

OP_CMP_LT (0x52)
----------------
Less Than Comparison

Encoding: [0x52]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a < b, else 0.

Example:
    Bytecode: 0x52
    Effect: result = (a < b) ? 1 : 0
    Source: x < y

OP_CMP_LE (0x53)
----------------
Less Than or Equal Comparison

Encoding: [0x53]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a <= b, else 0.

Example:
    Bytecode: 0x53
    Effect: result = (a <= b) ? 1 : 0
    Source: x <= y

OP_CMP_GT (0x54)
----------------
Greater Than Comparison

Encoding: [0x54]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a > b, else 0.

Example:
    Bytecode: 0x54
    Effect: result = (a > b) ? 1 : 0
    Source: x > y

OP_CMP_GE (0x55)
----------------
Greater Than or Equal Comparison

Encoding: [0x55]
Size: 1 byte
Stack: [a, b] → [result]
Description: Pops b then a, pushes 1 if a >= b, else 0.

Example:
    Bytecode: 0x55
    Effect: result = (a >= b) ? 1 : 0
    Source: x >= y

CONTROL FLOW
===========

OP_JUMP (0x60)
--------------
Unconditional Jump

Encoding: [0x60][jump32_offset]
Size: 5 bytes
Stack: [] → []
Description: Adds signed offset to program counter.

Example:
    Bytecode: 0x60 0x0A 0x00 0x00 0x00
    Effect: Jump forward 10 bytes
    Source: End of if statement body

Notes:
- Offset is relative to the start of the jump instruction
- Negative offsets jump backward (loops)
- Offset must point to valid instruction boundary

OP_JUMP_IF_FALSE (0x61)
-----------------------
Conditional Jump

Encoding: [0x61][jump32_offset]
Size: 5 bytes
Stack: [condition] → []
Description: Pops condition; if false/zero, jumps to offset.

Example:
    Bytecode: 0x61 0x14 0x00 0x00 0x00
    Effect: If condition is false, jump forward 20 bytes
    Source: if (x > 5) { ... }

Execution Flow:
1. Pop condition value from stack
2. If value is 0 (false), add offset to PC
3. If value is non-zero (true), continue to next instruction

OP_LOOP_START (0x62)
--------------------
Loop Start Marker

Encoding: [0x62]
Size: 1 byte
Stack: [] → []
Description: Marks beginning of loop construct.

Example:
    Bytecode: 0x62
    Effect: Loop boundary marker
    Source: while (condition) {

Notes:
- Currently used for documentation/debugging
- Future: break/continue statement support
- No runtime effect on execution

OP_LOOP_END (0x63)
------------------
Loop End Marker

Encoding: [0x63]
Size: 1 byte
Stack: [] → []
Description: Marks end of loop construct.

Example:
    Bytecode: 0x63
    Effect: Loop boundary marker
    Source: }

Notes:
- Paired with OP_LOOP_START
- Currently no runtime effect
- Future: loop optimization hints

FUNCTION OPERATIONS
==================

OP_CALL_BUILTIN (0x70)
----------------------
Call Built-in Function

Encoding: [0x70][function_name_offset32]
Size: 5 bytes
Stack: [args...] → [result]
Description: Calls built-in function by name.

Example:
    Bytecode: 0x70 0x08 0x00 0x00 0x00
    Effect: Calls function named at offset 8
    Source: abs(-5)

Calling Convention:
1. Arguments pushed to stack in left-to-right order
2. OP_CALL_BUILTIN pops arguments as needed
3. Function result (if any) pushed to stack
4. Execution continues after call

Built-in Functions:

abs(x):
    Arguments: 1 integer
    Returns: Absolute value of x
    Stack: [x] → [|x|]

min(a, b):
    Arguments: 2 integers
    Returns: Minimum of a and b
    Stack: [a, b] → [min(a,b)]

max(a, b):
    Arguments: 2 integers
    Returns: Maximum of a and b
    Stack: [a, b] → [max(a,b)]

file_exists():
    Arguments: None
    Returns: 1 (true) - placeholder
    Stack: [] → [1]

Error Conditions:
- Runtime error if function name not found
- Runtime error if wrong number of arguments
- Runtime error if argument types don't match

OP_CALL_USER (0x71)
-------------------
Call User-Defined Function

Encoding: [0x71][function_name_offset32]
Size: 5 bytes
Stack: [args...] → [result]
Description: Calls user-defined function by name.

Notes:
- Reserved for future implementation
- Currently generates runtime error
- Will support user function definitions

OP_RETURN (0x72)
----------------
Return from Function

Encoding: [0x72]
Size: 1 byte
Stack: [return_value] → []
Description: Returns from current function.

Notes:
- Reserved for future implementation
- Currently generates runtime error
- Will support function return values

INSTRUCTION SEQUENCES
====================

Common instruction patterns for typical language constructs:

Variable Assignment:
    Source: x = 42
    Bytecode:
        OP_LOAD_INT 42      // Push constant
        OP_STORE_VAR "x"    // Store in variable

Expression Evaluation:
    Source: print x + y * z
    Bytecode:
        OP_LOAD_VAR "x"     // Push x
        OP_LOAD_VAR "y"     // Push y
        OP_LOAD_VAR "z"     // Push z
        OP_MUL              // Calculate y * z
        OP_ADD              // Calculate x + (y * z)
        OP_PRINT_INT        // Print result

If Statement:
    Source: if (x > 5) { print x }
    Bytecode:
        OP_LOAD_VAR "x"     // Push x
        OP_LOAD_INT 5       // Push 5
        OP_CMP_GT           // Push (x > 5)
        OP_JUMP_IF_FALSE 8  // Skip print if false
        OP_LOAD_VAR "x"     // Push x
        OP_PRINT_INT        // Print x
        // Continue here if condition was false

While Loop:
    Source: while (x < 10) { x = x + 1 }
    Bytecode:
    loop_start:
        OP_LOAD_VAR "x"     // Push x
        OP_LOAD_INT 10      // Push 10
        OP_CMP_LT           // Push (x < 10)
        OP_JUMP_IF_FALSE 20 // Exit loop if false
        OP_LOAD_VAR "x"     // Push x
        OP_LOAD_INT 1       // Push 1
        OP_ADD              // Push (x + 1)
        OP_STORE_VAR "x"    // Store result
        OP_JUMP -24         // Jump back to loop_start
    loop_end:
        // Continue here after loop

Function Call:
    Source: print min(x, y)
    Bytecode:
        OP_LOAD_VAR "x"     // Push first argument
        OP_LOAD_VAR "y"     // Push second argument
        OP_CALL_BUILTIN "min" // Call function
        OP_PRINT_INT        // Print result

OPCODE SUMMARY TABLE
===================

Opcode | Name           | Size | Stack Effect      | Description
-------|----------------|------|--------------------|------------------
0x00   | OP_NOP         | 1    | [] → []           | No operation
0x01   | OP_EXIT        | 1    | [] → []           | Exit program
0x10   | OP_LOAD_INT    | 5    | [] → [int]        | Load integer
0x11   | OP_LOAD_FLOAT  | 5    | [] → [float]      | Load float
0x12   | OP_LOAD_STRING | 5    | [] → [string]     | Load string
0x20   | OP_LOAD_VAR    | 5    | [] → [value]      | Load variable
0x21   | OP_STORE_VAR   | 5    | [value] → []      | Store variable
0x30   | OP_PRINT_INT   | 1    | [int] → []        | Print integer
0x31   | OP_PRINT_STRING| 1    | [string] → []     | Print string
0x40   | OP_ADD         | 1    | [a,b] → [a+b]     | Addition
0x41   | OP_SUB         | 1    | [a,b] → [a-b]     | Subtraction
0x42   | OP_MUL         | 1    | [a,b] → [a*b]     | Multiplication
0x43   | OP_DIV         | 1    | [a,b] → [a/b]     | Division
0x50   | OP_CMP_EQ      | 1    | [a,b] → [a==b]    | Equal
0x51   | OP_CMP_NE      | 1    | [a,b] → [a!=b]    | Not equal
0x52   | OP_CMP_LT      | 1    | [a,b] → [a<b]     | Less than
0x53   | OP_CMP_LE      | 1    | [a,b] → [a<=b]    | Less or equal
0x54   | OP_CMP_GT      | 1    | [a,b] → [a>b]     | Greater than
0x55   | OP_CMP_GE      | 1    | [a,b] → [a>=b]    | Greater or equal
0x60   | OP_JUMP        | 5    | [] → []           | Unconditional jump
0x61   | OP_JUMP_IF_FALSE| 5   | [cond] → []       | Conditional jump
0x62   | OP_LOOP_START  | 1    | [] → []           | Loop start marker
0x63   | OP_LOOP_END    | 1    | [] → []           | Loop end marker
0x70   | OP_CALL_BUILTIN| 5    | [args] → [result] | Call built-in
0x71   | OP_CALL_USER   | 5    | [args] → [result] | Call user function
0x72   | OP_RETURN      | 1    | [value] → []      | Return from function

RESERVED OPCODES
===============

Opcodes 0x80-0xFF are reserved for future extensions:

Planned Opcodes:
- OP_ARRAY_GET/SET: Array operations
- OP_STRING_CONCAT: String concatenation  
- OP_TRY/CATCH: Exception handling
- OP_FOR_INIT/NEXT: For loop support
- OP_NATIVE_CALL: Call native RISC OS functions

DEBUGGING OPCODES
================

Future debugging support may include:
- OP_DEBUG_BREAK: Debugger breakpoint
- OP_DEBUG_PRINT: Debug output
- OP_DEBUG_STACK: Stack inspection
- OP_DEBUG_VARS: Variable inspection

ERROR HANDLING
=============

Runtime errors that can occur during opcode execution:

Stack Errors:
- Stack underflow (popping from empty stack)
- Stack overflow (too many values pushed)
- Type mismatch (wrong type for operation)

Variable Errors:
- Undefined variable access
- Invalid variable name

Arithmetic Errors:
- Division by zero
- Integer overflow (future)

Control Flow Errors:
- Invalid jump target
- Jump outside code section

Function Errors:
- Unknown function name
- Wrong argument count
- Invalid argument types

PERFORMANCE NOTES
================

Opcode execution performance characteristics:

Fast Operations (O(1)):
- All arithmetic operations
- All comparison operations
- Constant loading
- Stack operations

Slow Operations (O(n)):
- Variable lookup (linear search)
- Function name lookup (string comparison)
- String operations

Optimization Opportunities:
- Hash tables for variable/function lookup
- Interned strings for faster comparison
- Register-based instead of stack-based VM
- Bytecode peephole optimization

CONCLUSION
==========

This opcode reference provides complete documentation for the OakScript virtual
machine instruction set. The opcodes are designed for simplicity and ease of
implementation while providing sufficient functionality for a complete scripting
language. Future extensions will maintain backward compatibility with this core
instruction set.
